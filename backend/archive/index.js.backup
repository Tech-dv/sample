const express = require("express");
const cors = require("cors");
const fs = require("fs");
const path = require("path");
const XLSX = require("xlsx");
const pool = require("./db");

const app = express();
app.use(cors());
app.use(express.json());

/* =====================================================
   HELPER: Generate Train ID in format: financial_year/month/sequence
   Format: YYYY-YY/MM/001 (e.g., 2024-25/01/001)
   Financial year in India: April to March (April 2024 - March 2025 = 2024-25)
===================================================== */
async function generateTrainId() {
  const now = new Date();
  const currentYear = now.getFullYear();
  const currentMonth = now.getMonth() + 1; // 1-12 (January = 1, December = 12)

  // Determine financial year
  // If month is April (4) to December (12): currentYear-nextYear (e.g., 2024-25)
  // If month is January (1) to March (3): previousYear-currentYear (e.g., 2023-24)
  let financialYear;
  if (currentMonth >= 4) {
    // April to December: 2024-25
    const nextYear = (currentYear % 100) + 1;
    financialYear = `${currentYear}-${String(nextYear).padStart(2, '0')}`;
  } else {
    // January to March: 2023-24
    const prevYear = currentYear - 1;
    const currentYearShort = currentYear % 100;
    financialYear = `${prevYear}-${String(currentYearShort).padStart(2, '0')}`;
  }

  // Format month as 2 digits (01, 02, ..., 12)
  const monthStr = String(currentMonth).padStart(2, '0');

  // Find next available sequence number for this financial year/month
  // Pattern: financial_year/month/001, financial_year/month/002, etc.
  const pattern = `${financialYear}/${monthStr}/%`;

  // Check train_session for existing sequences (both train_id and rake_serial_number)
  const existingTrains = await pool.query(
    `SELECT train_id, rake_serial_number FROM train_session 
     WHERE train_id LIKE $1 OR rake_serial_number LIKE $1`,
    [pattern]
  );

  // Also check dashboard_records for rake_serial_number values
  // This is CRITICAL because when indents start counting, they get unique rake_serial_numbers
  // and we need to consider those when generating new train IDs
  // Example: If TRAIN-002 has indents with rake_serial_numbers 001, 002, 003,
  // then new TRAIN-003 should get 004 (not 002)
  const existingDashboardRecords = await pool.query(
    `SELECT DISTINCT rake_serial_number FROM dashboard_records 
     WHERE rake_serial_number LIKE $1 AND rake_serial_number IS NOT NULL`,
    [pattern]
  );

  // Extract sequence numbers from train_session (train_id and rake_serial_number)
  const trainSessionNumbers = existingTrains.rows
    .flatMap(row => {
      const numbers = [];
      // Check train_id
      if (row.train_id) {
        const match = row.train_id.match(/\/\d+\/(\d+)$/);
        if (match) numbers.push(parseInt(match[1], 10));
      }
      // Check rake_serial_number
      if (row.rake_serial_number) {
        const match = row.rake_serial_number.match(/\/\d+\/(\d+)$/);
        if (match) numbers.push(parseInt(match[1], 10));
      }
      return numbers;
    })
    .filter(num => num !== null);

  // Extract sequence numbers from dashboard_records (rake_serial_number)
  const dashboardNumbers = existingDashboardRecords.rows
    .map(row => {
      if (row.rake_serial_number) {
        const match = row.rake_serial_number.match(/\/\d+\/(\d+)$/);
        return match ? parseInt(match[1], 10) : null;
      }
      return null;
    })
    .filter(num => num !== null);

  // Combine all sequence numbers and find maximum
  const allSequenceNumbers = [...trainSessionNumbers, ...dashboardNumbers];
  const maxSequence = allSequenceNumbers.length > 0 ? Math.max(...allSequenceNumbers) : 0;

  // Find next available sequence number
  const nextSequence = maxSequence + 1;

  // Format sequence as 3 digits (001, 002, 003, etc.)
  const sequenceStr = String(nextSequence).padStart(3, '0');

  return `${financialYear}/${monthStr}/${sequenceStr}`;
}

/* =====================================================
   HELPER: Generate next unique rake serial number based on current one
   Takes a current rake serial number and finds the next available unique one
   by incrementing the sequence number until it finds one that's not used
===================================================== */
async function generateNextUniqueRakeSerialNumber(currentRakeSerialNumber) {
  // Parse the current rake serial number: format is YYYY-YY/MM/XXX
  const match = currentRakeSerialNumber.match(/^(\d{4}-\d{2})\/(\d{2})\/(\d+)$/);
  
  if (!match) {
    // If format doesn't match, fall back to generateTrainId()
    console.log(`[RAKE SERIAL] Invalid format for ${currentRakeSerialNumber}, using generateTrainId()`);
    return await generateTrainId();
  }

  const financialYear = match[1]; // e.g., "2025-26"
  const month = match[2]; // e.g., "02"
  const currentSequence = parseInt(match[3], 10); // e.g., 1

  // Start checking from currentSequence + 1
  let nextSequence = currentSequence + 1;
  let maxAttempts = 1000; // Safety limit
  let attempts = 0;

  while (attempts < maxAttempts) {
    const sequenceStr = String(nextSequence).padStart(3, '0');
    const candidateRakeSerial = `${financialYear}/${month}/${sequenceStr}`;

    // Check if this rake serial number is already used
    // Check both train_session and dashboard_records
    const trainSessionCheck = await pool.query(
      "SELECT 1 FROM train_session WHERE train_id = $1 OR rake_serial_number = $1 LIMIT 1",
      [candidateRakeSerial]
    );

    const dashboardCheck = await pool.query(
      "SELECT 1 FROM dashboard_records WHERE train_id = $1 OR rake_serial_number = $1 LIMIT 1",
      [candidateRakeSerial]
    );

    // If not found in either table, this is unique
    if (trainSessionCheck.rows.length === 0 && dashboardCheck.rows.length === 0) {
      console.log(`[RAKE SERIAL] Found unique rake serial number: ${candidateRakeSerial} (after ${attempts + 1} attempts)`);
      return candidateRakeSerial;
    }

    // This number is used, try next
    nextSequence++;
    attempts++;
  }

  // If we exhausted attempts, fall back to generateTrainId()
  console.log(`[RAKE SERIAL] Exhausted attempts to find unique number, using generateTrainId()`);
  return await generateTrainId();
}

/* =====================================================
   HELPER: Update Excel Template with Customers_Master Sheet
===================================================== */
async function updateExcelWithCustomers(excelFilePath) {
  try {
    // Check if file exists
    if (!fs.existsSync(excelFilePath)) {
      console.warn(`Excel file not found: ${excelFilePath}, skipping update`);
      return;
    }

    // Read existing Excel file
    const workbook = XLSX.readFile(excelFilePath);

    // Fetch all customers from database
    const customersRes = await pool.query(
      "SELECT id, customer_name FROM customers ORDER BY id ASC"
    );

    // Prepare Customers_Master sheet data
    const customersData = [
      ["Customer Name", "Customer ID"], // Header row
      ...customersRes.rows.map(c => [c.customer_name, c.id]) // Data rows
    ];

    // Create worksheet from data
    const customersSheet = XLSX.utils.aoa_to_sheet(customersData);

    // Remove existing Customers_Master sheet if it exists
    if (workbook.SheetNames.includes("Customers_Master")) {
      delete workbook.Sheets["Customers_Master"];
      const index = workbook.SheetNames.indexOf("Customers_Master");
      workbook.SheetNames.splice(index, 1);
    }

    // Add Customers_Master sheet
    workbook.SheetNames.push("Customers_Master");
    workbook.Sheets["Customers_Master"] = customersSheet;

    // Write updated workbook back to file
    XLSX.writeFile(workbook, excelFilePath);

    console.log(`Updated ${excelFilePath} with ${customersRes.rows.length} customers`);
  } catch (err) {
    console.error(`Error updating Excel file ${excelFilePath}:`, err);
    // Don't throw - allow customer creation to succeed even if Excel update fails
  }
}

/* =====================================================
   ROLE-BASED ACCESS MIDDLEWARE
===================================================== */
const allowRoles = (allowedRoles) => {
  return (req, res, next) => {
    const role = req.headers["x-user-role"];

    if (!role) {
      return res.status(403).json({ message: "Role missing" });
    }

    // SUPER_ADMIN has access to everything EXCEPT what's explicitly in allowedRoles
    // If allowedRoles doesn't include SUPER_ADMIN, they are denied access
    if (role === "SUPER_ADMIN" && !allowedRoles.includes("SUPER_ADMIN")) {
      return res.status(403).json({ message: "Access denied" });
    }

    // SUPER_ADMIN can access if they are in allowedRoles
    if (role === "SUPER_ADMIN" && allowedRoles.includes("SUPER_ADMIN")) {
      return next();
    }

    if (!allowedRoles.includes(role)) {
      return res.status(403).json({ message: "Access denied" });
    }

    next();
  };
};

/* =====================================================
   CUSTOMER CONTEXT MIDDLEWARE
===================================================== */
const withCustomerContext = (req, res, next) => {
  const role = req.headers["x-user-role"];
  const customerId = req.headers["x-customer-id"];

  if (role === "CUSTOMER") {
    if (!customerId) {
      return res.status(403).json({ message: "Customer identity missing" });
    }
    req.customerId = Number(customerId);
  }

  next();
};




/* =====================================================
   LOGIN
===================================================== */
app.post("/login", async (req, res) => {
  const { username, password } = req.body;

  try {
    const result = await pool.query(
      `
      SELECT
        u.id,
        u.username,
        u.role,
        u.customer_id,
        c.customer_name
      FROM users u
      LEFT JOIN customers c ON c.id = u.customer_id
      WHERE u.username=$1 AND u.password=$2 AND u.is_active = true
      `,
      [username, password]
    );

    if (!result.rows.length) {
      return res.status(401).json({ message: "Invalid credentials" });
    }

    res.json(result.rows[0]);
  } catch (err) {
    console.error("LOGIN ERROR:", err);
    res.status(500).json({ message: "Server error" });
  }
});


/* =====================================================
   NEW TRAIN ARRIVAL
===================================================== */

app.post("/train", async (req, res) => {
  const { wagon_count, siding } = req.body;

  console.log("TRAIN BODY:", req.body);

  try {
    // Generate rake_serial_number in format (financial_year/month/sequence)
    const rakeSerialNumber = await generateTrainId();
    console.log(`Generated rake_serial_number: ${rakeSerialNumber}`);

    // Generate train_id for internal reference only (format: TRAIN-XXX)
    // This is kept only in train_session for backward compatibility
    const finalTrainId = `TRAIN-${String(Math.floor(Math.random() * 10000)).padStart(3, '0')}`;

    // Check if rake_serial_number already exists
    const exists = await pool.query(
      "SELECT 1 FROM train_session WHERE rake_serial_number = $1",
      [rakeSerialNumber]
    );

    if (exists.rows.length > 0) {
      return res.json({
        message: "Train already exists, ignored",
        rake_serial_number: rakeSerialNumber
      });
    }

    // Check if rake_serial_number column exists, if not add it
    try {
      await pool.query("ALTER TABLE train_session ADD COLUMN IF NOT EXISTS rake_serial_number TEXT");
    } catch (alterErr) {
      // Column might already exist, ignore error
      console.log("Column rake_serial_number already exists or alter failed:", alterErr.message);
    }

    const trainResult = await pool.query(
      `
      INSERT INTO train_session (train_id, wagon_count, siding, rake_serial_number)
      VALUES ($1, $2, $3, $4)
      RETURNING created_time
      `,
      [
        finalTrainId,
        wagon_count ?? null,
        siding ?? null,
        rakeSerialNumber
      ]
    );

    const createdTime = trainResult.rows[0].created_time;

    // Check if rake_serial_number column exists in dashboard_records, if not add it
    try {
      await pool.query("ALTER TABLE dashboard_records ADD COLUMN IF NOT EXISTS rake_serial_number TEXT");
    } catch (alterErr) {
      // Column might already exist, ignore error
      console.log("Column rake_serial_number already exists in dashboard_records or alter failed:", alterErr.message);
    }

    await pool.query(
      `
      INSERT INTO dashboard_records (rake_serial_number, created_time, status, siding)
      VALUES ($1, $2, 'DRAFT', $3)
      `,
      [rakeSerialNumber, createdTime, siding ?? null]
    );

    if (wagon_count > 0) {
      for (let i = 1; i <= wagon_count; i++) {
        await pool.query(
          `
          INSERT INTO wagon_records (
            tower_number,
            loaded_bag_count,
            unloaded_bag_count,
            wagon_to_be_loaded,
            loading_status,
            rake_serial_number
          )
          VALUES ($1, 0, 0, 0, false, $2)
          `,
          [i, rakeSerialNumber]
        );
      }
    }

    res.json({
      message: "Train created",
      rake_serial_number: rakeSerialNumber,
      wagon_count,
      siding
    });

  } catch (err) {
    console.error("TRAIN ERROR:", err);
    res.status(500).json({ message: "Server error" });
  }
});




/* =====================================================
   DASHBOARD DATA (CURRENT TRAIN + CAMERA STATS)
===================================================== */
app.get("/dashboard-data", async (req, res) => {
  console.log("=== Dashboard data request received ===");
  console.log("Headers:", req.headers);

  try {
    // Ensure rake_serial_number column exists in dashboard_records and train_sessions
    try {
      await pool.query("ALTER TABLE dashboard_records ADD COLUMN IF NOT EXISTS rake_serial_number TEXT");
      await pool.query("ALTER TABLE train_session ADD COLUMN IF NOT EXISTS rake_serial_number TEXT");
    } catch (alterErr) {
      // Column might already exist, but log the error for debugging
      console.log("Column rake_serial_number check:", alterErr.message);
    }

    // Check if rake_serial_number column exists by trying to query it
    let hasRakeSerialColumn = false;
    try {
      await pool.query("SELECT rake_serial_number FROM dashboard_records LIMIT 1");
      hasRakeSerialColumn = true;
    } catch (checkErr) {
      console.log("rake_serial_number column not available yet, using train_id only");
      hasRakeSerialColumn = false;
    }

    const role = req.headers["x-user-role"];
    const customerIdRaw = req.headers["x-customer-id"];
    const customerId = Number(customerIdRaw);
    const username = req.headers["x-username"];

    console.log("Role:", role);
    console.log("Customer ID:", customerIdRaw);
    console.log("Username:", username);

    if (role === "CUSTOMER" && (!customerIdRaw || Number.isNaN(customerId))) {
      console.error("Invalid customer ID for CUSTOMER role");
      return res.status(400).json({
        message: "Invalid or missing customer id",
      });
    }


    /* =====================================================
       DASHBOARD TABLE DATA (ROLE AWARE)
    ===================================================== */

    // Simplified query: dashboard_records now has one row per indent (for multiple indent trains)
    // So we can directly query dashboard_records and join with wagons for aggregation
    // Rake Loading Start/End times are calculated from wagon records (first/last by tower_number)
    let tableQuery;
    let tableParams = [];

    // Build train_id selection - use rake_serial_number as train_id for backward compatibility
    const trainIdSelect = "d.rake_serial_number AS train_id, d.rake_serial_number";

    if (role === "CUSTOMER") {
      tableQuery = `
          SELECT
            ${trainIdSelect},
            d.indent_number,
            d.siding,
            c.customer_name,
            d.wagon_destination,
            d.status,
            d.created_time,
            COALESCE(
            (
              SELECT STRING_AGG(DISTINCT w_comm.commodity, ', ' ORDER BY w_comm.commodity)
              FROM wagon_records w_comm
              WHERE w_comm.rake_serial_number = d.rake_serial_number
                AND (d.single_indent = true OR w_comm.indent_number = d.indent_number)
                AND w_comm.commodity IS NOT NULL
                AND w_comm.commodity != ''
            ),
            d.commodity,
            ''
          ) AS commodity,
          (
            SELECT w_first.loading_start_time
            FROM wagon_records w_first
            WHERE w_first.rake_serial_number = d.rake_serial_number
              AND (d.single_indent = true OR w_first.indent_number = d.indent_number)
              AND w_first.loading_start_time IS NOT NULL
            ORDER BY w_first.tower_number ASC
            LIMIT 1
          ) AS rake_loading_start_datetime,
          (
            SELECT w_last.loading_end_time
            FROM wagon_records w_last
            WHERE w_last.rake_serial_number = d.rake_serial_number
              AND (d.single_indent = true OR w_last.indent_number = d.indent_number)
              AND w_last.loading_end_time IS NOT NULL
            ORDER BY w_last.tower_number DESC
            LIMIT 1
          ) AS rake_loading_end_actual,
          COALESCE(SUM(w.loaded_bag_count), 0) AS total_bags_loaded,
          COALESCE(SUM(w.wagon_to_be_loaded), 0) AS total_bags_to_be_loaded
        FROM dashboard_records d
        JOIN customers c ON c.id = d.customer_id
        LEFT JOIN wagon_records w ON w.rake_serial_number = d.rake_serial_number
          AND (d.single_indent = true OR w.indent_number = d.indent_number)
          WHERE d.customer_id = $1 AND (d.status IS NULL OR d.status != 'CANCELLED')
            -- Exclude parent records when child records (with sequential numbers) exist
            AND NOT (
              -- Check if this is a parent record (no sequential number in rake_serial_number)
              d.rake_serial_number !~ '^(.+\/\d+\/\d+)-(\d+)$'
              -- AND there exist child records with sequential numbers
              AND EXISTS (
                SELECT 1 FROM dashboard_records d2
                WHERE d2.rake_serial_number ~ '^(.+\/\d+\/\d+)-(\d+)$'
                  -- Extract base rake_serial_number from sequential pattern (e.g., 2025-26/01/001-1 -> 2025-26/01/001)
                  AND regexp_replace(d2.rake_serial_number, '-(\d+)$', '') = d.rake_serial_number
                  AND d2.customer_id = $1
                  AND (d2.status IS NULL OR d2.status != 'CANCELLED')
              )
            )
          GROUP BY
            d.rake_serial_number,
            d.indent_number,
            d.siding,
            c.customer_name,
            d.wagon_destination,
            d.status,
            d.created_time,
            d.commodity,
            d.single_indent
          ORDER BY d.created_time DESC
        `;
      tableParams = [customerId];
    } else if (role === "SUPER_ADMIN") {
      // SUPER_ADMIN: show only
      // - APPROVED rows (rake loading completed)
      // - LOADING_IN_PROGRESS rows that were revoked by this SUPER_ADMIN
      tableQuery = `
          SELECT
            ${trainIdSelect},
            d.indent_number,
            d.siding,
            c.customer_name,
            d.wagon_destination,
            d.status,
            d.assigned_reviewer,
            d.created_time,
            COALESCE(
            (
              SELECT STRING_AGG(DISTINCT w_comm.commodity, ', ' ORDER BY w_comm.commodity)
              FROM wagon_records w_comm
              WHERE w_comm.rake_serial_number = d.rake_serial_number
                AND (d.single_indent = true OR w_comm.indent_number = d.indent_number)
                AND w_comm.commodity IS NOT NULL
                AND w_comm.commodity != ''
            ),
            d.commodity,
            ''
          ) AS commodity,
          (
            SELECT w_first.loading_start_time
            FROM wagon_records w_first
            WHERE w_first.rake_serial_number = d.rake_serial_number
              AND (d.single_indent = true OR w_first.indent_number = d.indent_number)
              AND w_first.loading_start_time IS NOT NULL
            ORDER BY w_first.tower_number ASC
            LIMIT 1
          ) AS rake_loading_start_datetime,
          (
            SELECT w_last.loading_end_time
            FROM wagon_records w_last
            WHERE w_last.rake_serial_number = d.rake_serial_number
              AND (d.single_indent = true OR w_last.indent_number = d.indent_number)
              AND w_last.loading_end_time IS NOT NULL
            ORDER BY w_last.tower_number DESC
            LIMIT 1
          ) AS rake_loading_end_actual,
          COALESCE(SUM(w.loaded_bag_count), 0) AS total_bags_loaded,
          COALESCE(SUM(w.wagon_to_be_loaded), 0) AS total_bags_to_be_loaded
        FROM dashboard_records d
        LEFT JOIN customers c ON c.id = d.customer_id
        LEFT JOIN wagon_records w ON w.rake_serial_number = d.rake_serial_number
          AND (d.single_indent = true OR w.indent_number = d.indent_number)
          WHERE 
            (d.status = 'APPROVED'
            OR (
              d.status = 'LOADING_IN_PROGRESS'
              AND EXISTS (
                SELECT 1 
                FROM activity_timeline a
                WHERE a.rake_serial_number = d.rake_serial_number
                  AND (
                    (a.indent_number IS NULL AND (d.indent_number IS NULL OR d.indent_number = ''))
                    OR a.indent_number = d.indent_number
                  )
                  AND a.activity_type = 'REVOKED_BY_SUPER_ADMIN'
                  AND a.username = $1
              )
            ))
            -- Exclude parent records when child records (with sequential numbers) exist
            AND NOT (
              -- Check if this is a parent record (no sequential number in rake_serial_number)
              d.rake_serial_number !~ '^(.+\/\d+\/\d+)-(\d+)$'
              -- AND there exist child records with sequential numbers
              AND EXISTS (
                SELECT 1 FROM dashboard_records d2
                WHERE d2.rake_serial_number ~ '^(.+\/\d+\/\d+)-(\d+)$'
                  -- Extract base rake_serial_number from sequential pattern (e.g., 2025-26/01/001-1 -> 2025-26/01/001)
                  AND regexp_replace(d2.rake_serial_number, '-(\d+)$', '') = d.rake_serial_number
                  AND (d2.status = 'APPROVED' OR d2.status = 'LOADING_IN_PROGRESS')
              )
            )
          GROUP BY
            d.rake_serial_number,
            d.indent_number,
            d.siding,
            c.customer_name,
            d.wagon_destination,
            d.status,
            d.assigned_reviewer,
            d.created_time,
            d.commodity,
            d.single_indent
          ORDER BY d.created_time DESC
        `;
      tableParams = [username || ""];
    } else {
      // ADMIN / REVIEWER:
      // Show all non-cancelled rows, but mark rows that were revoked by ANY SUPER_ADMIN
      // so frontend can disable Edit while still allowing View.
      tableQuery = `
          SELECT
            ${trainIdSelect},
            d.indent_number,
            d.siding,
            c.customer_name,
            d.wagon_destination,
            d.status,
            d.assigned_reviewer,
            d.created_time,
            COALESCE(
            (
              SELECT STRING_AGG(DISTINCT w_comm.commodity, ', ' ORDER BY w_comm.commodity)
              FROM wagon_records w_comm
              WHERE w_comm.rake_serial_number = d.rake_serial_number
                AND (d.single_indent = true OR w_comm.indent_number = d.indent_number)
                AND w_comm.commodity IS NOT NULL
                AND w_comm.commodity != ''
            ),
            d.commodity,
            ''
          ) AS commodity,
          (
            SELECT w_first.loading_start_time
            FROM wagon_records w_first
            WHERE w_first.rake_serial_number = d.rake_serial_number
              AND (d.single_indent = true OR w_first.indent_number = d.indent_number)
              AND w_first.loading_start_time IS NOT NULL
            ORDER BY w_first.tower_number ASC
            LIMIT 1
          ) AS rake_loading_start_datetime,
          (
            SELECT w_last.loading_end_time
            FROM wagon_records w_last
            WHERE w_last.rake_serial_number = d.rake_serial_number
              AND (d.single_indent = true OR w_last.indent_number = d.indent_number)
              AND w_last.loading_end_time IS NOT NULL
            ORDER BY w_last.tower_number DESC
            LIMIT 1
          ) AS rake_loading_end_actual,
          COALESCE(SUM(w.loaded_bag_count), 0) AS total_bags_loaded,
          COALESCE(SUM(w.wagon_to_be_loaded), 0) AS total_bags_to_be_loaded,
          EXISTS (
            SELECT 1
            FROM activity_timeline a
            WHERE a.rake_serial_number = d.rake_serial_number
              AND (
                (a.indent_number IS NULL AND (d.indent_number IS NULL OR d.indent_number = ''))
                OR a.indent_number = d.indent_number
              )
              AND a.activity_type = 'REVOKED_BY_SUPER_ADMIN'
          ) AS revoked_by_superadmin
        FROM dashboard_records d
        LEFT JOIN customers c ON c.id = d.customer_id
        LEFT JOIN wagon_records w ON w.rake_serial_number = d.rake_serial_number
          AND (d.single_indent = true OR w.indent_number = d.indent_number)
          WHERE (d.status IS NULL OR d.status != 'CANCELLED')
            -- Exclude parent records when child records (with sequential numbers) exist
            AND NOT (
              -- Check if this is a parent record (no sequential number in rake_serial_number)
              d.rake_serial_number !~ '^(.+\/\d+\/\d+)-(\d+)$'
              -- AND there exist child records with sequential numbers
              AND EXISTS (
                SELECT 1 FROM dashboard_records d2
                WHERE d2.rake_serial_number ~ '^(.+\/\d+\/\d+)-(\d+)$'
                  -- Extract base rake_serial_number from sequential pattern (e.g., 2025-26/01/001-1 -> 2025-26/01/001)
                  AND regexp_replace(d2.rake_serial_number, '-(\d+)$', '') = d.rake_serial_number
                  AND (d2.status IS NULL OR d2.status != 'CANCELLED')
              )
            )
          GROUP BY
            d.rake_serial_number,
            d.indent_number,
            d.siding,
            c.customer_name,
            d.wagon_destination,
            d.status,
            d.assigned_reviewer,
            d.created_time,
            d.commodity,
            d.single_indent
          ORDER BY d.created_time DESC
        `;
      tableParams = [];
    }
    const tableResult = await pool.query(tableQuery, tableParams);

    /* =====================================================
       CUSTOMER SUMMARY
    ===================================================== */
    if (role === "CUSTOMER") {
      const summaryRes = await pool.query(
        `
        SELECT
          COUNT(DISTINCT d.train_id) AS total_trains,
          COUNT(w.wagon_number) AS total_wagon,
          COALESCE(SUM(w.loaded_bag_count), 0) AS total_bags_loaded
        FROM dashboard_records d
        LEFT JOIN wagon_records w ON w.train_id = d.train_id
        WHERE d.customer_id = $1
        `,
        [customerId]
      );

      return res.json({
        summary: {
          customerSummary: {
            total_trains: Number(summaryRes.rows[0].total_trains),
            total_wagons: Number(
              summaryRes.rows[0].total_wagon
            ),
            total_bags_loaded: Number(
              summaryRes.rows[0].total_bags_loaded
            ),
          },
        },
        records: tableResult.rows,
      });
    }

    /* =====================================================
       ADMIN / REVIEWER SUMMARY (SPUR + CAMERA)
    ===================================================== */

    const getCurrentTrainStats = async (spur) => {
      // Get all active trains (not APPROVED) for this spur
      // This includes split trains like 2024-25/01/001, 2024-25/01/001-1, 2024-25/01/001-2
      const trainsRes = await pool.query(
        `
        SELECT DISTINCT train_id, status
        FROM dashboard_records
        WHERE siding = $1 AND status != 'APPROVED'
        `,
        [spur]
      );

      if (!trainsRes.rows.length) {
        console.log(`${spur}: No active trains found`);
        return { completed: 0, total: 0 };
      }

      // Get all train_ids
      const trainIds = trainsRes.rows.map(r => r.train_id);
      console.log(`${spur}: Active train IDs:`, trainIds);

      // Count wagons across ALL these trains (including split ones)
      const wagonRes = await pool.query(
        `
        SELECT
          COUNT(*) AS total_wagons,
          COUNT(*) FILTER (
            WHERE loaded_bag_count >= wagon_to_be_loaded AND loaded_bag_count > 0
          ) AS completed_wagons
        FROM wagon_records
        WHERE train_id = ANY($1)
        `,
        [trainIds]
      );

      const total = Number(wagonRes.rows[0]?.total_wagons || 0);
      const completed = Number(wagonRes.rows[0]?.completed_wagons || 0);

      console.log(`${spur}: Wagon stats - Completed: ${completed}, Total: ${total}`);

      return { completed, total };
    };


    const getCameraStats = async (spur) => {
      const camRes = await pool.query(
        `
        SELECT
          COUNT(*) AS total_cameras,
          COUNT(*) FILTER (WHERE status = true) AS active_cameras
        FROM camera_records
        WHERE siding = $1
        `,
        [spur]
      );

      return {
        active: Number(camRes.rows[0].active_cameras),
        total: Number(camRes.rows[0].total_cameras),
      };
    };

    res.json({
      summary: {
        spurSummary: {
          "SPUR-8": {
            wagons: await getCurrentTrainStats("SPUR-8"),
            cameras: await getCameraStats("SPUR-8"),
          },
          "SPUR-9": {
            wagons: await getCurrentTrainStats("SPUR-9"),
            cameras: await getCameraStats("SPUR-9"),
          },
        },
      },
      records: tableResult.rows,
    });
    console.log("=== Dashboard data response sent successfully ===");
    console.log("Records count:", tableResult.rows.length);
  } catch (err) {
    console.error("=== DASHBOARD ERROR ===", err);
    console.error("Error stack:", err.stack);
    res.status(500).json({ message: "Dashboard fetch failed" });
  }
});

app.get("/customers", allowRoles(["ADMIN", "SUPER_ADMIN", "REVIEWER"]), async (req, res) => {
  try {
    const result = await pool.query(
      `SELECT id, customer_name FROM customers ORDER BY customer_name`
    );
    res.json(result.rows);
  } catch (err) {
    console.error("CUSTOMERS LOAD ERROR:", err);
    res.status(500).json({ message: "Failed to load customers" });
  }
});

// Create new customer + corresponding CUSTOMER user
app.post("/customers", allowRoles(["SUPER_ADMIN", "ADMIN", "REVIEWER"]), async (req, res) => {
  const { customer_name, password } = req.body || {};

  if (!customer_name || !customer_name.trim() || !password || !password.trim()) {
    return res.status(400).json({ message: "customer_name and password are required" });
  }

  const name = customer_name.trim();
  const pwd = password.trim();

  try {
    // Check if username already exists
    const existingUser = await pool.query(
      "SELECT 1 FROM users WHERE username = $1",
      [name]
    );
    if (existingUser.rows.length > 0) {
      return res.status(409).json({ message: "Username already exists" });
    }

    // Generate next customer_code based on max(id)
    const seqRes = await pool.query("SELECT COALESCE(MAX(id), 0) + 1 AS next_id FROM customers");
    const nextId = seqRes.rows[0].next_id;
    const customerCode = `CUST-${String(nextId).padStart(3, "0")}`;

    // Insert into customers
    const custRes = await pool.query(
      `
      INSERT INTO customers (customer_code, customer_name, created_at)
      VALUES ($1, $2, NOW())
      RETURNING id, customer_code, customer_name, created_at
      `,
      [customerCode, name]
    );

    const customerId = custRes.rows[0].id;

    // Insert corresponding CUSTOMER user
    await pool.query(
      `
      INSERT INTO users (username, password, role, customer_id, is_active, created_at)
      VALUES ($1, $2, 'CUSTOMER', $3, true, NOW())
      `,
      [name, pwd, customerId]
    );

    // Update both Excel template files with new customer
    const frontendPublicPath = path.join(__dirname, "..", "frontend", "public");
    const singleIndentPath = path.join(frontendPublicPath, "single_indent.xlsx");
    const multipleIndentPath = path.join(frontendPublicPath, "mulitple_indent.xlsx");

    // Update both files asynchronously (don't wait for completion)
    updateExcelWithCustomers(singleIndentPath).catch(err =>
      console.error("Failed to update single_indent.xlsx:", err)
    );
    updateExcelWithCustomers(multipleIndentPath).catch(err =>
      console.error("Failed to update mulitple_indent.xlsx:", err)
    );

    res.status(201).json({
      message: "Customer created successfully",
      customer: custRes.rows[0],
    });
  } catch (err) {
    console.error("CREATE CUSTOMER ERROR:", err);
    res.status(500).json({ message: "Failed to create customer" });
  }
});

/* =====================================================
   CREATE REVIEWER USER (SUPER_ADMIN ONLY)
===================================================== */
app.post("/users/reviewer", allowRoles(["SUPER_ADMIN"]), async (req, res) => {
  const { username, password } = req.body || {};

  if (!username || !username.trim() || !password || !password.trim()) {
    return res.status(400).json({ message: "username and password are required" });
  }

  const name = username.trim();
  const pwd = password.trim();

  try {
    const existingUser = await pool.query(
      "SELECT 1 FROM users WHERE username = $1",
      [name]
    );
    if (existingUser.rows.length > 0) {
      return res.status(409).json({ message: "Username already exists" });
    }

    await pool.query(
      `
      INSERT INTO users (username, password, role, customer_id, is_active, created_at)
      VALUES ($1, $2, 'REVIEWER', NULL, true, NOW())
      `,
      [name, pwd]
    );

    res.status(201).json({ message: "Reviewer user created successfully" });
  } catch (err) {
    console.error("CREATE REVIEWER USER ERROR:", err);
    res.status(500).json({ message: "Failed to create reviewer user" });
  }
});

/* =====================================================
   CREATE ADMIN USER (SUPER_ADMIN + REVIEWER)
===================================================== */
app.post("/users/admin", allowRoles(["SUPER_ADMIN", "REVIEWER"]), async (req, res) => {
  const { username, password } = req.body || {};

  if (!username || !username.trim() || !password || !password.trim()) {
    return res.status(400).json({ message: "username and password are required" });
  }

  const name = username.trim();
  const pwd = password.trim();

  try {
    const existingUser = await pool.query(
      "SELECT 1 FROM users WHERE username = $1",
      [name]
    );
    if (existingUser.rows.length > 0) {
      return res.status(409).json({ message: "Username already exists" });
    }

    await pool.query(
      `
      INSERT INTO users (username, password, role, customer_id, is_active, created_at)
      VALUES ($1, $2, 'ADMIN', NULL, true, NOW())
      `,
      [name, pwd]
    );

    res.status(201).json({ message: "Admin user created successfully" });
  } catch (err) {
    console.error("CREATE ADMIN USER ERROR:", err);
    res.status(500).json({ message: "Failed to create admin user" });
  }
});

/* =====================================================
   CREATE SUPER_ADMIN USER (SUPER_ADMIN ONLY)
===================================================== */
app.post("/users/superadmin", allowRoles(["SUPER_ADMIN"]), async (req, res) => {
  const { username, password } = req.body || {};

  if (!username || !username.trim() || !password || !password.trim()) {
    return res.status(400).json({ message: "username and password are required" });
  }

  const name = username.trim();
  const pwd = password.trim();

  try {
    const existingUser = await pool.query(
      "SELECT 1 FROM users WHERE username = $1",
      [name]
    );
    if (existingUser.rows.length > 0) {
      return res.status(409).json({ message: "Username already exists" });
    }

    await pool.query(
      `
      INSERT INTO users (username, password, role, customer_id, is_active, created_at)
      VALUES ($1, $2, 'SUPER_ADMIN', NULL, true, NOW())
      `,
      [name, pwd]
    );

    res.status(201).json({ message: "Super Admin user created successfully" });
  } catch (err) {
    console.error("CREATE SUPER_ADMIN USER ERROR:", err);
    res.status(500).json({ message: "Failed to create superadmin user" });
  }
});

/* =====================================================
   SAVE AS DRAFT
===================================================== */
app.put(
  "/dashboard-record/:train_id/draft",
  allowRoles(["ADMIN", "SUPER_ADMIN"]),
  async (req, res) => {
    const { indent_number } = req.body;
    const train_id = req.params.train_id;

    const statusRes = await pool.query(
      "SELECT status FROM dashboard_records WHERE train_id=$1",
      [train_id]
    );

    if (!statusRes.rows.length) {
      return res.status(404).json({ message: "Train not found" });
    }

    if (["PENDING_APPROVAL", "APPROVED"].includes(statusRes.rows[0].status)) {
      return res.status(403).json({ message: "Cannot edit after submission" });
    }

    await pool.query(
      `
      UPDATE dashboard_records
      SET indent_number = $1,
          status = 'DRAFT'
      WHERE train_id = $2
      `,
      [indent_number || null, train_id]
    );

    res.json({ message: "Saved as draft" });
  }
);




/* =====================================================
   REVIEWER TASK LIST
===================================================== */
app.get(
  "/tasks",
  allowRoles(["REVIEWER"]),
  async (req, res) => {
    try {
      const result = await pool.query(
        `
        SELECT
          d.train_id,
          d.indent_number,
          d.siding,
          d.created_time,
          c.customer_name
        FROM dashboard_records d
        LEFT JOIN customers c ON c.id = d.customer_id
        WHERE d.status = 'PENDING_APPROVAL'
        ORDER BY d.created_time DESC
        `
      );

      res.json(result.rows);
    } catch (err) {
      console.error("TASK LIST ERROR:", err);
      res.status(500).json({ message: "Task fetch failed" });
    }
  }
);


/* =====================================================
   APPROVE / REJECT
===================================================== */
app.put(
  "/tasks/:train_id/approve",
  allowRoles(["REVIEWER"]),
  async (req, res) => {
    await pool.query(
      "UPDATE dashboard_records SET status='APPROVED' WHERE train_id=$1",
      [req.params.train_id]
    );
    res.json({ message: "Approved" });
  }
);

app.put(
  "/tasks/:train_id/reject",
  allowRoles(["REVIEWER"]),
  async (req, res) => {
    await pool.query(
      "UPDATE dashboard_records SET status='REJECTED' WHERE train_id=$1",
      [req.params.train_id]
    );
    res.json({ message: "Rejected" });
  }
);

/* =====================================================
   VIEW TRAIN DETAILS (READ-ONLY)
===================================================== */
app.get("/train/:trainId/view", withCustomerContext, async (req, res) => {
  const { trainId } = req.params;
  // trainId may be URL encoded (e.g., "2025-26%2F01%2F001"), decode it
  const decodedTrainId = decodeURIComponent(trainId);
  const role = req.headers["x-user-role"];
  const customerId = req.customerId;

  try {
    const indentNumber = req.query.indent_number; // Optional: filter by indent

    // Build header query based on whether indent_number is provided
    // Check both train_id and rake_serial_number since URL might use either
    let headerQuery, headerParams;

    if (indentNumber && indentNumber !== null && indentNumber !== '') {
      // Get specific indent row
      if (role === "CUSTOMER") {
        headerQuery = `
          SELECT d.*, c.customer_name
          FROM dashboard_records d
          JOIN customers c ON c.id = d.customer_id
          WHERE (d.train_id=$1 OR d.rake_serial_number=$1) AND d.customer_id=$2 AND d.indent_number=$3
        `;
        headerParams = [decodedTrainId, customerId, indentNumber];
      } else {
        headerQuery = `
          SELECT d.*, c.customer_name
          FROM dashboard_records d
          LEFT JOIN customers c ON c.id = d.customer_id
          WHERE (d.train_id=$1 OR d.rake_serial_number=$1) AND d.indent_number=$2
        `;
        headerParams = [decodedTrainId, indentNumber];
      }
    } else {
      // Get first available row (prefer row with null/empty indent_number for first entry)
      if (role === "CUSTOMER") {
        headerQuery = `
          SELECT d.*, c.customer_name
          FROM dashboard_records d
          JOIN customers c ON c.id = d.customer_id
          WHERE (d.train_id=$1 OR d.rake_serial_number=$1) AND d.customer_id=$2
          ORDER BY 
            CASE WHEN d.indent_number IS NULL OR d.indent_number = '' THEN 0 ELSE 1 END,
            d.indent_number
          LIMIT 1
        `;
        headerParams = [decodedTrainId, customerId];
      } else {
        headerQuery = `
          SELECT d.*, c.customer_name
          FROM dashboard_records d
          LEFT JOIN customers c ON c.id = d.customer_id
          WHERE d.train_id=$1 OR d.rake_serial_number=$1
          ORDER BY 
            CASE WHEN d.indent_number IS NULL OR d.indent_number = '' THEN 0 ELSE 1 END,
            d.indent_number
          LIMIT 1
        `;
        headerParams = [decodedTrainId];
      }
    }

    const header = await pool.query(headerQuery, headerParams);

    if (!header.rows.length) {
      return res.status(403).json({ message: "Access denied" });
    }

    const headerData = header.rows[0];
    const indentNum = indentNumber !== undefined ? indentNumber : headerData.indent_number;

    // Use the actual train_id from header (not the URL parameter) for subsequent queries
    // ✅ FIX: Also get rake_serial_number for queries
    const actualTrainId = headerData.train_id;
    const actualRakeSerialNumber = headerData.rake_serial_number || null;

    // Filter wagons by indent_number
    // If indentNumber is explicitly provided in query AND it's not null/empty, filter by it
    // If indentNumber is null/empty (first entry), show all wagons
    // If multiple indent mode and indentNum exists, filter by it
    // Otherwise, show all wagons
    // ✅ FIX: Use both train_id and rake_serial_number for wagon queries
    let wagonQuery, wagonParams;
    if (indentNumber !== undefined && indentNumber !== null && indentNumber !== '') {
      // indentNumber explicitly provided and not empty - filter by it
      wagonQuery = `
        SELECT * FROM wagon_records 
        WHERE (train_id=$1 OR rake_serial_number=$1) AND indent_number=$2 
        ORDER BY tower_number
      `;
      wagonParams = [actualTrainId, indentNumber];
    } else if (headerData.single_indent === false && indentNum && indentNum !== null && indentNum !== '') {
      // Multiple indent mode with valid indent_number - filter by it
      wagonQuery = `
        SELECT * FROM wagon_records 
        WHERE (train_id=$1 OR rake_serial_number=$1) AND indent_number=$2 
        ORDER BY tower_number
      `;
      wagonParams = [actualTrainId, indentNum];
    } else {
      // No indent_number or first entry - show all wagons
      wagonQuery = `
        SELECT * FROM wagon_records 
        WHERE (train_id=$1 OR rake_serial_number=$1)
        ORDER BY tower_number
      `;
      wagonParams = [actualTrainId];
    }

    const wagons = await pool.query(wagonQuery, wagonParams);

    const dispatch = await pool.query(
      "SELECT * FROM dispatch_records WHERE (train_id=$1 OR rake_serial_number=$1)",
      [actualTrainId]
    );

    res.json({
      header: headerData,
      wagons: wagons.rows,
      dispatch: dispatch.rows[0] || null,
    });
  } catch (err) {
    console.error("VIEW TRAIN ERROR", err);
    res.status(500).json({ message: "Failed to load train view" });
  }
});



app.get("/train/:trainId/edit", async (req, res) => {
  const { trainId } = req.params;
  // trainId may be URL encoded (e.g., "2025-26%2F01%2F001"), decode it
  const decodedTrainId = decodeURIComponent(trainId);
  const indentNumber = req.query.indent_number; // Optional: filter by indent

  try {
    // Build query based on whether indent_number is provided
    let headerQuery, headerParams;

    if (indentNumber && indentNumber !== null && indentNumber !== '') {
      // Get specific indent row
      // Check both train_id and rake_serial_number since URL might use either
      headerQuery = `
      SELECT
        d.train_id,
        d.indent_number,
        d.customer_id,
        d.status,
          d.single_indent,
          d.hl_only,
          d.wagon_destination,
          d.commodity,
          d.siding,
          d.has_sequential_serials
        FROM dashboard_records d
        WHERE (d.train_id = $1 OR d.rake_serial_number = $1) AND d.indent_number = $2
      `;
      headerParams = [decodedTrainId, indentNumber];
    } else {
      // Get first available row (prefer row with null/empty indent_number for first entry)
      // If no such row exists, get any row
      // Check both train_id and rake_serial_number since URL might use either
      headerQuery = `
        SELECT
          d.train_id,
          d.indent_number,
          d.customer_id,
          d.status,
          d.single_indent,
          d.hl_only,
          d.wagon_destination,
          d.commodity,
          d.siding,
          d.has_sequential_serials
      FROM dashboard_records d
      WHERE d.train_id = $1 OR d.rake_serial_number = $1
        ORDER BY 
          CASE WHEN d.indent_number IS NULL OR d.indent_number = '' THEN 0 ELSE 1 END,
          d.indent_number
        LIMIT 1
      `;
      headerParams = [decodedTrainId];
    }

    const headerRes = await pool.query(headerQuery, headerParams);

    if (!headerRes.rows.length) {
      return res.status(404).json({ message: "Train not found" });
    }

    const header = headerRes.rows[0];
    const indentNum = indentNumber !== undefined ? indentNumber : header.indent_number;

    // Filter wagons by indent_number
    // Use the actual train_id from header (not the URL parameter) for wagon queries
    // since wagon_records uses train_id, not rake_serial_number
    const actualTrainId = header.train_id;

    // ✅ FIX: Get rake_serial_number for queries
    let actualRakeSerialNumber = null;
    try {
      const rakeSerialRes = await pool.query(
        "SELECT rake_serial_number FROM train_session WHERE train_id = $1 OR rake_serial_number = $1 LIMIT 1",
        [actualTrainId]
      );
      actualRakeSerialNumber = rakeSerialRes.rows[0]?.rake_serial_number || null;
    } catch (err) {
      console.error("Error getting rake_serial_number:", err);
    }

    // If indentNumber is explicitly provided in query AND it's not null/empty, filter by it
    // If indentNumber is null/empty (first entry), show all wagons
    // If multiple indent mode and indentNum exists, filter by it
    // Otherwise, show all wagons
    // ✅ FIX: Use both train_id and rake_serial_number for queries
    let wagonQuery, wagonParams;
    if (indentNumber !== undefined && indentNumber !== null && indentNumber !== '') {
      // indentNumber explicitly provided and not empty - filter by it
      wagonQuery = `
        SELECT *
        FROM wagon_records
        WHERE (train_id = $1 OR rake_serial_number = $1) AND indent_number = $2
        ORDER BY tower_number
      `;
      wagonParams = [actualTrainId, indentNumber];
    } else if (header.single_indent === false && indentNum && indentNum !== null && indentNum !== '') {
      // Multiple indent mode with valid indent_number - filter by it
      wagonQuery = `
        SELECT *
        FROM wagon_records
        WHERE (train_id = $1 OR rake_serial_number = $1) AND indent_number = $2
        ORDER BY tower_number
      `;
      wagonParams = [actualTrainId, indentNum];
    } else {
      // No indent_number or first entry - show all wagons
      wagonQuery = `
      SELECT *
      FROM wagon_records
      WHERE (train_id = $1 OR rake_serial_number = $1)
      ORDER BY tower_number
      `;
      wagonParams = [actualTrainId];
    }

    const wagonRes = await pool.query(wagonQuery, wagonParams);

    // Determine if this is a child record:
    // 1. Check if train_id has sequential pattern (e.g., 2025-26/01/001-1)
    // 2. OR check if it has an indent_number and is in multiple indent mode (parent was split)
    const hasSequentialPattern = actualTrainId.match(/^(.+\/\d+\/\d+)-(\d+)$/) !== null;
    const isMultipleIndent = header.single_indent === false;
    const hasIndentNumber = header.indent_number && header.indent_number !== '';
    const isChildRecord = hasSequentialPattern || (isMultipleIndent && hasIndentNumber);

    let wagonCount = null;

    if (isChildRecord) {
      // For child records, use the actual count of wagons for this indent
      wagonCount = wagonRes.rows.length;
      console.log(`[TRAIN_EDIT API] Child record detected (sequential: ${hasSequentialPattern}, multiple indent: ${isMultipleIndent && hasIndentNumber}), using actual wagon count: ${wagonCount}`);
    } else {
      // For parent records, get wagon_count from train_session
      const trainSessionRes = await pool.query(
        "SELECT wagon_count FROM train_session WHERE train_id = $1 OR rake_serial_number = $1",
        [actualTrainId]
      );
      wagonCount = trainSessionRes.rows[0]?.wagon_count || null;
      console.log(`[TRAIN_EDIT API] Parent record, using wagon_count from train_session: ${wagonCount}`);
    }

    console.log(`[TRAIN_EDIT API] URL trainId: ${decodedTrainId}, actual train_id: ${actualTrainId}, isChildRecord: ${isChildRecord}, wagon_count: ${wagonCount}, existing wagons: ${wagonRes.rows.length}`);

    res.json({
      header: {
        ...header,
        wagon_count: wagonCount, // Include wagon_count from train_session
        is_child_record: isChildRecord, // Flag to indicate if this is a child record
      },
      wagons: wagonRes.rows,
    });
  } catch (err) {
    console.error("LOAD TRAIN ERROR:", err);
    res.status(500).json({ message: "Failed to load train data" });
  }
});



app.post("/train/:trainId/draft", async (req, res) => {
  const { trainId } = req.params;
  const { header, wagons, editOptions } = req.body;
  const singleIndent = editOptions?.singleIndent !== undefined ? editOptions.singleIndent : true;
  const hlOnly = editOptions?.wagonTypeHL !== undefined ? editOptions.wagonTypeHL : false;

  // ✅ FIX: Resolve actualTrainId FIRST before fetching existing data for comparison
  // The URL trainId might be either train_id or rake_serial_number
  // Use the same logic as GET /train/:trainId/edit endpoint
  const decodedTrainId = decodeURIComponent(trainId);
  let actualTrainId = decodedTrainId;
  let actualRakeSerialNumber = null;
  try {
    // First try train_session
    const trainSessionRes = await pool.query(
      "SELECT train_id, rake_serial_number FROM train_session WHERE train_id = $1 OR rake_serial_number = $1 LIMIT 1",
      [decodedTrainId]
    );
    if (trainSessionRes.rows.length > 0) {
      actualTrainId = trainSessionRes.rows[0].train_id;
      actualRakeSerialNumber = trainSessionRes.rows[0].rake_serial_number || null;
      console.log(`[DRAFT SAVE] Found in train_session: actualTrainId=${actualTrainId}, actualRakeSerialNumber=${actualRakeSerialNumber}`);
    } else {
      // If not found in train_session, try dashboard_records
      // For multiple indent mode, we need to get the train_id from any matching record
      // Prefer records where train_id != rake_serial_number (parent records)
      const dashboardRes = await pool.query(
        `SELECT train_id, rake_serial_number FROM dashboard_records 
         WHERE train_id = $1 OR rake_serial_number = $1 
         ORDER BY CASE WHEN train_id != rake_serial_number OR rake_serial_number IS NULL THEN 0 ELSE 1 END
         LIMIT 1`,
        [decodedTrainId]
      );
      if (dashboardRes.rows.length > 0) {
        actualTrainId = dashboardRes.rows[0].train_id;
        actualRakeSerialNumber = dashboardRes.rows[0].rake_serial_number || null;
        console.log(`[DRAFT SAVE] Found in dashboard_records: actualTrainId=${actualTrainId}, actualRakeSerialNumber=${actualRakeSerialNumber}`);
      } else {
        console.log(`[DRAFT SAVE] Not found in train_session or dashboard_records, using URL trainId as fallback: ${decodedTrainId}`);
      }
    }
    console.log(`[DRAFT SAVE] Resolved trainId: URL=${decodedTrainId}, actualTrainId=${actualTrainId}, actualRakeSerialNumber=${actualRakeSerialNumber}`);
  } catch (err) {
    console.error("Error resolving actualTrainId for activity timeline:", err);
    // Continue with trainId as fallback
  }

  // ✅ FIX: Get existing data BEFORE updating (for activity timeline comparison)
  const reviewerUsername = req.headers["x-reviewer-username"];
  const userRole = req.headers["x-user-role"];
  let existingHeaders = [];
  let existingWagons = [];

  if (reviewerUsername && (userRole === "REVIEWER" || userRole === "ADMIN")) {
    // Get existing header data for comparison
    let existingHeaderQuery, existingHeaderParams;
    if (singleIndent) {
      existingHeaderQuery = `
        SELECT indent_number, customer_id, wagon_destination, commodity
        FROM dashboard_records
        WHERE train_id = $1 OR rake_serial_number = $1
        LIMIT 1
      `;
      existingHeaderParams = [actualTrainId];
    } else {
      const indentNumbersInWagons = [...new Set(
        wagons.map(w => w.indent_number).filter(Boolean)
      )];
      if (indentNumbersInWagons.length > 0) {
        existingHeaderQuery = `
          SELECT indent_number, customer_id, wagon_destination, commodity
          FROM dashboard_records
          WHERE (train_id = $1 OR rake_serial_number = $1) AND indent_number = ANY($2)
        `;
        existingHeaderParams = [actualTrainId, indentNumbersInWagons];
      }
    }

    if (existingHeaderQuery) {
      const existingHeaderRes = await pool.query(existingHeaderQuery, existingHeaderParams);
      existingHeaders = existingHeaderRes.rows || [];
    }

    // Get existing wagons for comparison - use actualTrainId (wagon_records uses train_id)
    let existingWagonsQuery, existingWagonsParams;
    if (singleIndent) {
      existingWagonsQuery = `
        SELECT wagon_number, wagon_type, cc_weight, sick_box, wagon_to_be_loaded,
               commodity, seal_number, stoppage_time, remarks, loading_status,
               indent_number, wagon_destination, customer_id, tower_number
        FROM wagon_records
        WHERE train_id = $1
        ORDER BY tower_number
      `;
      existingWagonsParams = [actualTrainId];
      console.log(`[ACTIVITY TIMELINE] Fetching existing wagons (single indent mode) for train_id: ${actualTrainId}`);
    } else {
      const indentNumbersInWagons = [...new Set(
        wagons.map(w => w.indent_number).filter(Boolean)
      )];
      if (indentNumbersInWagons.length > 0) {
        existingWagonsQuery = `
          SELECT wagon_number, wagon_type, cc_weight, sick_box, wagon_to_be_loaded,
                 commodity, seal_number, stoppage_time, remarks, loading_status,
                 indent_number, wagon_destination, customer_id, tower_number
          FROM wagon_records
          WHERE train_id = $1 AND indent_number = ANY($2)
          ORDER BY tower_number
        `;
        existingWagonsParams = [actualTrainId, indentNumbersInWagons];
        console.log(`[ACTIVITY TIMELINE] Fetching existing wagons (multiple indent mode) for train_id: ${actualTrainId}, indent_numbers: ${indentNumbersInWagons.join(', ')}`);
      } else {
        console.log(`[ACTIVITY TIMELINE] No indent numbers found in wagons, skipping existing wagons query`);
      }
    }

    if (existingWagonsQuery) {
      const existingWagonsRes = await pool.query(existingWagonsQuery, existingWagonsParams);
      existingWagons = existingWagonsRes.rows || [];
      console.log(`[ACTIVITY TIMELINE] Fetched ${existingWagons.length} existing wagons from database`);
      if (existingWagons.length === 0) {
        console.log(`[ACTIVITY TIMELINE] WARNING: No existing wagons found! Query: ${existingWagonsQuery}, Params: ${JSON.stringify(existingWagonsParams)}`);
      }
    } else {
      console.log(`[ACTIVITY TIMELINE] WARNING: No existing wagons query generated!`);
    }
  }

  try {
    // ✅ FIX: First, resolve the actual train_id and rake_serial_number from train_session
    // The URL trainId might be either train_id or rake_serial_number
    // Note: actualTrainId was already resolved above for fetching existing wagons
    const trainSessionRes = await pool.query(
      "SELECT train_id, rake_serial_number, siding FROM train_session WHERE train_id = $1 OR rake_serial_number = $1 LIMIT 1",
      [trainId]
    );
    
    // Get the actual train_id and rake_serial_number from train_session
    // Use the already resolved actualTrainId from above, or resolve it again here if needed
    const actualTrainIdFromSession = trainSessionRes.rows[0]?.train_id || trainId; // Fallback to URL trainId if not found
    // Update actualTrainId if we got a better value from the session (should already be set from above)
    if (actualTrainIdFromSession && actualTrainIdFromSession !== trainId) {
      actualTrainId = actualTrainIdFromSession;
    }
    // ✅ FIX: Get rake_serial_number (will be declared later if needed)
    let actualRakeSerialNumber = trainSessionRes.rows[0]?.rake_serial_number || null;
    
    // Get existing dashboard record to preserve siding and created_time
    // Check both train_id and rake_serial_number since URL might use either
    const existingRecord = await pool.query(
      "SELECT siding, created_time FROM dashboard_records WHERE train_id = $1 OR rake_serial_number = $1 LIMIT 1",
      [actualTrainId]
    );

    // Priority:
    // 1. Siding from train_session (Master record)
    // 2. Siding from request body (if sent)
    // 3. Siding from existing dashboard record
    const siding = trainSessionRes.rows[0]?.siding || header?.siding || existingRecord.rows[0]?.siding || null;
    const createdTime = existingRecord.rows[0]?.created_time || new Date();

    // Check if train already has sequential serials flag (needed for sequential assignment logic later)
    // Check both train_id and rake_serial_number since URL might use either
    const existingRecordDataForFlag = await pool.query(
      "SELECT has_sequential_serials FROM dashboard_records WHERE train_id = $1 OR rake_serial_number = $1 LIMIT 1",
      [actualTrainId]
    );
    let hasSequentialSerials = existingRecordDataForFlag.rows[0]?.has_sequential_serials || false;

    if (singleIndent) {
      /* ===============================
           SINGLE INDENT MODE: One row per train
         =============================== */
      const firstCommodity = wagons.find(w => w.commodity)?.commodity || null;
      const firstWagonDestination = wagons.find(w => w.wagon_destination)?.wagon_destination || null;

      // Check if train already has sequential serials flag, assigned_reviewer, and status (before delete)
      // Check both train_id and rake_serial_number since URL might use either
      const existingRecordData = await pool.query(
        "SELECT has_sequential_serials, assigned_reviewer, status FROM dashboard_records WHERE train_id = $1 OR rake_serial_number = $1 LIMIT 1",
        [actualTrainId]
      );
      hasSequentialSerials = existingRecordData.rows[0]?.has_sequential_serials || false;
      const assignedReviewer = existingRecordData.rows[0]?.assigned_reviewer || null;
      const existingStatus = existingRecordData.rows[0]?.status || 'DRAFT';

      // Preserve LOADING_IN_PROGRESS and PENDING_APPROVAL statuses, otherwise use DRAFT
      const statusToUse = (existingStatus === 'LOADING_IN_PROGRESS' || existingStatus === 'PENDING_APPROVAL') ? existingStatus : 'DRAFT';

      // Delete any existing dashboard records for this train (handles both single and multiple indent cases)
      // Use actualTrainId to ensure we delete the correct records
      await pool.query(
        "DELETE FROM dashboard_records WHERE train_id = $1 OR rake_serial_number = $1",
        [actualTrainId]
      );

      // Insert single dashboard record (preserve flag, assigned_reviewer, and status)
      // Use actualTrainId and actualRakeSerialNumber from train_session
      await pool.query(
        `
          INSERT INTO dashboard_records (
            train_id, rake_serial_number, indent_number, customer_id, commodity, 
            wagon_destination, status, single_indent, hl_only, siding, created_time, has_sequential_serials, assigned_reviewer
          )
          VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
        `,
        [
          actualTrainId,
          actualRakeSerialNumber,
          header.indent_number || null,
          header.customer_id || null,
          firstCommodity,
          firstWagonDestination,
          statusToUse,
          singleIndent,
          hlOnly,
          siding,
          createdTime,
          hasSequentialSerials,
          assignedReviewer,
        ]
      );
    } else {
      /* ===============================
         MULTIPLE INDENT MODE: One row per indent
         =============================== */

      // Get distinct indent numbers from wagons
      const indentGroups = {};
      wagons.forEach(w => {
        const indentNum = w.indent_number || null;
        if (indentNum) {
          if (!indentGroups[indentNum]) {
            indentGroups[indentNum] = {
              indent_number: indentNum,
              customer_id: w.customer_id || null,
              commodity: w.commodity || null,
              wagon_destination: w.wagon_destination || null,
            };
          }
        }
      });

      // Check if train already has sequential serials flag, assigned_reviewer, and status (before any operations)
      // Check both train_id and rake_serial_number since URL might use either
      const existingRecordData = await pool.query(
        "SELECT has_sequential_serials, assigned_reviewer, status, siding, created_time FROM dashboard_records WHERE train_id = $1 OR rake_serial_number = $1 LIMIT 1",
        [actualTrainId]
      );
      hasSequentialSerials = existingRecordData.rows[0]?.has_sequential_serials || false;
      console.log(`[DEBUG] Train ${actualTrainId}: hasSequentialSerials = ${hasSequentialSerials}`);
      const assignedReviewer = existingRecordData.rows[0]?.assigned_reviewer || null;
      const existingStatus = existingRecordData.rows[0]?.status || 'DRAFT';
      // ✅ FIX: Prioritize siding from train_session (siding variable) over existing dashboard record
      // The 'siding' variable already includes logic to fallback to existing record if train_session is empty
      const preservedSiding = siding || existingRecordData.rows[0]?.siding;
      const preservedCreatedTime = existingRecordData.rows[0]?.created_time || createdTime;

      // Preserve LOADING_IN_PROGRESS and PENDING_APPROVAL statuses, otherwise use DRAFT
      const statusToUse = (existingStatus === 'LOADING_IN_PROGRESS' || existingStatus === 'PENDING_APPROVAL') ? existingStatus : 'DRAFT';

      // ONLY delete dashboard records for the indent numbers we're saving
      // This prevents deleting other indent number rows when editing just one
      // Use actualTrainId to ensure we delete the correct records
      const indentNumbersToSave = Object.keys(indentGroups);
      if (indentNumbersToSave.length > 0) {
        // Also delete any parent/initial records with null or empty indent_number
        await pool.query(
          `DELETE FROM dashboard_records 
           WHERE (train_id = $1 OR rake_serial_number = $1)
           AND (indent_number = ANY($2) OR indent_number IS NULL OR indent_number = '' OR single_indent = true)`,
          [actualTrainId, indentNumbersToSave]
        );
      }

      // Create/update one dashboard record per indent (preserve flag, assigned_reviewer, and status)
      // ✅ FIX: For each indent, preserve its existing rake_serial_number from dashboard_records
      // Don't overwrite with base rake_serial_number from train_session
      for (const indentNum of indentNumbersToSave) {
        const indentData = indentGroups[indentNum];

        // ✅ FIX: Get existing rake_serial_number for this specific indent from dashboard_records
        // This preserves the unique rake_serial_number assigned to each indent
        let indentRakeSerialNumber = actualRakeSerialNumber; // Default to base if not found
        try {
          const existingIndentRes = await pool.query(
            `SELECT rake_serial_number FROM dashboard_records 
             WHERE (train_id = $1 OR rake_serial_number = $1) AND indent_number = $2 LIMIT 1`,
            [actualTrainId, indentNum]
          );
          if (existingIndentRes.rows.length > 0 && existingIndentRes.rows[0].rake_serial_number) {
            indentRakeSerialNumber = existingIndentRes.rows[0].rake_serial_number;
            console.log(`[DRAFT SAVE] Preserving rake_serial_number ${indentRakeSerialNumber} for indent ${indentNum}`);
          }
        } catch (err) {
          console.error(`[DRAFT SAVE] Error getting existing rake_serial_number for indent ${indentNum}:`, err);
        }

        await pool.query(
          `
          INSERT INTO dashboard_records (
            train_id, rake_serial_number, indent_number, customer_id, commodity,
            wagon_destination, status, single_indent, hl_only, siding, created_time, has_sequential_serials, assigned_reviewer
          )
          VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
          `,
          [
            actualTrainId,
            indentRakeSerialNumber, // ✅ FIX: Use indent-specific rake_serial_number, not base
            indentData.indent_number,
            indentData.customer_id,
            indentData.commodity,
            indentData.wagon_destination,
            statusToUse,
            singleIndent,
            hlOnly,
            preservedSiding,
            preservedCreatedTime,
            hasSequentialSerials,
            assignedReviewer,
          ]
        );
      }
    }


    /* ===============================
       2️⃣ PRESERVE EXISTING LOADING TIMES BEFORE DELETING
       =============================== */
    // ✅ FIX: Preserve loading_start_time and loading_end_time from existing wagons
    // These are auto-populated by the bag counting system and should not be overwritten
    // Use wagon_number + indent_number as primary key (more stable than tower_number)
    // Fallback to tower_number + indent_number if wagon_number is not available
    let existingTimesMap = {};

    // ✅ FIX: Get rake_serial_number for queries (if not already set above)
    // Note: actualRakeSerialNumber is already declared earlier in the function
    if (!actualRakeSerialNumber) {
      try {
        const rakeSerialRes = await pool.query(
          "SELECT rake_serial_number FROM train_session WHERE train_id = $1 OR rake_serial_number = $1 LIMIT 1",
          [actualTrainId]
        );
        actualRakeSerialNumber = rakeSerialRes.rows[0]?.rake_serial_number || null;
      } catch (err) {
        console.error("Error getting rake_serial_number:", err);
      }
    }

    if (singleIndent) {
      // Get all existing wagons for this train - use both train_id and rake_serial_number
      // ✅ FIX: Check actualTrainId, actualRakeSerialNumber, and original trainId (URL parameter)
      // This ensures we find wagons regardless of which identifier is used
      const queryParams = [actualTrainId];
      let queryConditions = `(train_id = $1 OR rake_serial_number = $1)`;
      let paramIndex = 2;
      
      // Add actualRakeSerialNumber if it's different from actualTrainId
      if (actualRakeSerialNumber && actualRakeSerialNumber !== actualTrainId) {
        queryParams.push(actualRakeSerialNumber);
        queryConditions += ` OR (train_id = $${paramIndex} OR rake_serial_number = $${paramIndex})`;
        paramIndex++;
      }
      
      // Add original trainId if it's different from both
      if (trainId !== actualTrainId && trainId !== actualRakeSerialNumber) {
        queryParams.push(trainId);
        queryConditions += ` OR (train_id = $${paramIndex} OR rake_serial_number = $${paramIndex})`;
        paramIndex++;
      }
      
      const existingWagons = await pool.query(
        `SELECT wagon_number, tower_number, indent_number, loading_start_time, loading_end_time, loaded_bag_count, unloaded_bag_count
         FROM wagon_records 
         WHERE ${queryConditions}`,
        queryParams
      );

      console.log(`[PRESERVE TIMES] Fetched ${existingWagons.rows.length} existing wagons for single indent mode. actualTrainId: ${actualTrainId}, actualRakeSerialNumber: ${actualRakeSerialNumber}, original trainId: ${trainId}, queryParams: ${JSON.stringify(queryParams)}`);

      // Map by wagon_number (if available) or tower_number for quick lookup
      existingWagons.rows.forEach(row => {
        const key = row.wagon_number && row.wagon_number.trim() !== ""
          ? `wagon_${row.wagon_number.trim()}`
          : `tower_${row.tower_number || ''}`;
        existingTimesMap[key] = {
          loading_start_time: row.loading_start_time,
          loading_end_time: row.loading_end_time,
          loaded_bag_count: row.loaded_bag_count,
          unloaded_bag_count: row.unloaded_bag_count,
        };
        console.log(`[PRESERVE TIMES] Mapped key "${key}" with times: start=${row.loading_start_time || 'null'}, end=${row.loading_end_time || 'null'}`);
      });
    } else {
      // Get existing wagons for the indent numbers being saved
      const indentNumbersInWagons = [...new Set(
        wagons.map(w => w.indent_number).filter(Boolean)
      )];

      if (indentNumbersInWagons.length > 0) {
        // ✅ FIX: Only get wagons for the specific indent numbers being saved
        // Don't include NULL/empty indent_number wagons in multiple indent mode
        // ✅ FIX: Check actualTrainId, actualRakeSerialNumber, and original trainId (URL parameter)
        // This ensures we find wagons regardless of which identifier is used
        const queryParams = [actualTrainId];
        let queryConditions = `(train_id = $1 OR rake_serial_number = $1)`;
        let paramIndex = 2;
        
        // Add actualRakeSerialNumber if it's different from actualTrainId
        if (actualRakeSerialNumber && actualRakeSerialNumber !== actualTrainId) {
          queryParams.push(actualRakeSerialNumber);
          queryConditions += ` OR (train_id = $${paramIndex} OR rake_serial_number = $${paramIndex})`;
          paramIndex++;
        }
        
        // Add original trainId if it's different from both
        if (trainId !== actualTrainId && trainId !== actualRakeSerialNumber) {
          queryParams.push(trainId);
          queryConditions += ` OR (train_id = $${paramIndex} OR rake_serial_number = $${paramIndex})`;
          paramIndex++;
        }
        
        // Add indent numbers
        queryParams.push(indentNumbersInWagons);
        queryConditions += ` AND indent_number = ANY($${paramIndex})`;
        
        const existingWagons = await pool.query(
          `SELECT wagon_number, tower_number, indent_number, loading_start_time, loading_end_time, loaded_bag_count, unloaded_bag_count
           FROM wagon_records 
           WHERE ${queryConditions}`,
          queryParams
        );

        console.log(`[PRESERVE TIMES] Fetched ${existingWagons.rows.length} existing wagons for multiple indent mode. actualTrainId: ${actualTrainId}, actualRakeSerialNumber: ${actualRakeSerialNumber}, original trainId: ${trainId}, indentNumbers: ${indentNumbersInWagons.join(', ')}, queryParams: ${JSON.stringify(queryParams)}`);

        // Map by wagon_number + indent_number (if available) or tower_number + indent_number
        existingWagons.rows.forEach(row => {
          // ✅ FIX: Normalize indent_number (treat null and empty string the same)
          const indentNum = (row.indent_number && row.indent_number.trim() !== "") ? row.indent_number.trim() : '';

          // Create keys for both wagon_number and tower_number lookups
          if (row.wagon_number && row.wagon_number.trim() !== "") {
            const wagonKey = `wagon_${row.wagon_number.trim()}_indent_${indentNum}`;
            existingTimesMap[wagonKey] = {
              loading_start_time: row.loading_start_time,
              loading_end_time: row.loading_end_time,
            };
            console.log(`[PRESERVE TIMES] Mapped key "${wagonKey}" with times: start=${row.loading_start_time || 'null'}, end=${row.loading_end_time || 'null'}`);
          }
          // Also create tower_number key as fallback
          if (row.tower_number) {
            const towerKey = `tower_${row.tower_number}_indent_${indentNum}`;
            // Only set if not already set by wagon_number (wagon_number takes priority)
            if (!existingTimesMap[towerKey]) {
              existingTimesMap[towerKey] = {
                loading_start_time: row.loading_start_time,
                loading_end_time: row.loading_end_time,
                loaded_bag_count: row.loaded_bag_count,
                unloaded_bag_count: row.unloaded_bag_count,
              };
              console.log(`[PRESERVE TIMES] Mapped key "${towerKey}" with times: start=${row.loading_start_time || 'null'}, end=${row.loading_end_time || 'null'}`);
            }
          }
        });
      }
    }

    /* ===============================
       3️⃣ DELETE OLD WAGONS
       =============================== */
    // In multiple indent mode, only delete wagons for the indent numbers we're saving
    // In single indent mode, delete all wagons for this train
    // ✅ FIX: Use both train_id and rake_serial_number for deletion
    // Also check original trainId (URL parameter) in case it's a rake_serial_number
    if (singleIndent) {
      await pool.query(
        "DELETE FROM wagon_records WHERE ((train_id = $1 OR rake_serial_number = $1) OR (train_id = $2 OR rake_serial_number = $2))",
        [actualTrainId, trainId] // Check both resolved train_id and original URL trainId
      );
    } else {
      // Get distinct indent numbers from wagons being saved
      const indentNumbersInWagons = [...new Set(
        wagons.map(w => w.indent_number).filter(Boolean)
      )];

      if (indentNumbersInWagons.length > 0) {
        // Also delete any wagons with null or empty indent_number (parent wagons)
        // ✅ FIX: Use both train_id and rake_serial_number, and also check original trainId
        await pool.query(
          `DELETE FROM wagon_records 
           WHERE ((train_id = $1 OR rake_serial_number = $1) OR (train_id = $3 OR rake_serial_number = $3))
           AND (indent_number = ANY($2) OR indent_number IS NULL OR indent_number = '')`,
          [actualTrainId, indentNumbersInWagons, trainId] // Check both resolved train_id and original URL trainId
        );
      }
    }

    /* ===============================
       4️⃣ INSERT WAGONS (TABLE-ALIGNED)
       =============================== */
    // ✅ FIX: Create a map of indent_number -> rake_serial_number from dashboard_records
    // This ensures each indent uses its correct rake_serial_number, not the base one
    const indentRakeSerialMap = {};
    if (!singleIndent) {
      const indentNumbersInWagons = [...new Set(
        wagons.map(w => w.indent_number || header.indent_number).filter(Boolean)
      )];
      if (indentNumbersInWagons.length > 0) {
        const indentRakeRes = await pool.query(
          `SELECT indent_number, rake_serial_number FROM dashboard_records 
           WHERE (train_id = $1 OR rake_serial_number = $1) AND indent_number = ANY($2)`,
          [actualTrainId, indentNumbersInWagons]
        );
        indentRakeRes.rows.forEach(row => {
          if (row.indent_number && row.rake_serial_number) {
            indentRakeSerialMap[row.indent_number] = row.rake_serial_number;
          }
        });
        console.log(`[DRAFT SAVE] Mapped indent rake_serial_numbers:`, indentRakeSerialMap);
      }
    }

    for (const w of wagons) {
      // ✅ FIX: Normalize indent_number (treat null and empty string the same)
      // This is used for both rake_serial_number lookup and loading times preservation
      const indentNum = (w.indent_number && w.indent_number.trim() !== "")
        ? w.indent_number.trim()
        : ((header.indent_number && header.indent_number.trim() !== "") ? header.indent_number.trim() : '');
      
      // ✅ FIX: Get the correct rake_serial_number for this wagon's indent
      // For multiple indent mode, use the indent-specific rake_serial_number
      // For single indent mode, use the base rake_serial_number
      const wagonRakeSerialNumber = (!singleIndent && indentNum && indentRakeSerialMap[indentNum])
        ? indentRakeSerialMap[indentNum]
        : actualRakeSerialNumber;

      // ✅ FIX: Check if loading_status was manually set by user
      // If provided explicitly, use it; otherwise calculate based on bag counts
      let loadingStatus;

      if (w.loading_status !== undefined && w.loading_status !== null) {
        // User manually set the status - use it directly
        loadingStatus = Boolean(w.loading_status);
      } else {
        // Calculate based on bag counts
        const wagonToBeLoaded = w.wagon_to_be_loaded != null && w.wagon_to_be_loaded !== ""
          ? Number(w.wagon_to_be_loaded)
          : null;
        const loadedBagCount = Number(w.loaded_bag_count) || 0;

        // Loading is complete only if:
        // 1. wagon_to_be_loaded is set (not null) AND
        // 2. loaded_bag_count >= wagon_to_be_loaded AND
        // 3. loaded_bag_count > 0 (at least one bag loaded)
        loadingStatus = wagonToBeLoaded != null
          ? (loadedBagCount >= wagonToBeLoaded && loadedBagCount > 0)
          : false;
      }

      // ✅ FIX: Preserve existing loading times if they exist
      // These are auto-populated by the bag counting system and should NEVER be overwritten by frontend
      // Frontend no longer sends these fields, so we always preserve existing times
      // Try multiple matching strategies for reliability

      let existingTimes = {};

      // Strategy 1: Try wagon_number + indent_number (most reliable)
      if (w.wagon_number && w.wagon_number.trim() !== "") {
        const key1 = singleIndent
          ? `wagon_${w.wagon_number.trim()}`
          : `wagon_${w.wagon_number.trim()}_indent_${indentNum}`;
        if (existingTimesMap[key1]) {
          existingTimes = existingTimesMap[key1];
        }
      }

      // Strategy 2: Try tower_number + indent_number (fallback)
      if (!existingTimes.loading_start_time && !existingTimes.loading_end_time) {
        const key2 = singleIndent
          ? `tower_${w.tower_number || ''}`
          : `tower_${w.tower_number || ''}_indent_${indentNum}`;
        if (existingTimesMap[key2]) {
          existingTimes = existingTimesMap[key2];
        }
      }

      // Strategy 3: For multiple indent mode, try matching by indent_number and tower_number
      if (!singleIndent && !existingTimes.loading_start_time && !existingTimes.loading_end_time && indentNum) {
        // Try to find any wagon with same tower_number in this indent
        const key3 = `tower_${w.tower_number || ''}_indent_${indentNum}`;
        if (existingTimesMap[key3]) {
          existingTimes = existingTimesMap[key3];
        }
      }

      // Strategy 4: Last resort - try to find any wagon in same indent with same tower_number
      if (!existingTimes.loading_start_time && !existingTimes.loading_end_time && w.tower_number) {
        // Search through all entries in the map for this indent and tower_number
        for (const [key, times] of Object.entries(existingTimesMap)) {
          if (key.includes(`tower_${w.tower_number}`) && (singleIndent || key.includes(`indent_${indentNum}`))) {
            if (times.loading_start_time || times.loading_end_time) {
              existingTimes = times;
              break;
            }
          }
        }
      }

      const loadingStartTime = existingTimes.loading_start_time || null;
      const loadingEndTime = existingTimes.loading_end_time || null;

      // ✅ FIX: Preserve bag counts if frontend sends 0 but DB has values
      // This prevents overwriting counts from the bag counting system
      const loadedBagCount = (w.loaded_bag_count == 0 || w.loaded_bag_count == null) && existingTimes.loaded_bag_count > 0
        ? existingTimes.loaded_bag_count
        : (w.loaded_bag_count || 0);

      const unloadedBagCount = (w.unloaded_bag_count == 0 || w.unloaded_bag_count == null) && existingTimes.unloaded_bag_count > 0
        ? existingTimes.unloaded_bag_count
        : (w.unloaded_bag_count || 0);

      // ✅ FIX: Log if times are being lost (for debugging)
      if (w.tower_number && !loadingStartTime && !loadingEndTime && Object.keys(existingTimesMap).length > 0) {
        console.log(`[WARNING] Could not preserve loading times for wagon tower_number=${w.tower_number}, indent_number=${indentNum}, wagon_number=${w.wagon_number || 'N/A'}`);
        console.log(`[DEBUG] Available keys in existingTimesMap:`, Object.keys(existingTimesMap));
        console.log(`[DEBUG] actualTrainId: ${actualTrainId}, original trainId: ${trainId}`);
      }
      
      // ✅ FIX: Log when times ARE preserved (for verification)
      if (loadingStartTime || loadingEndTime) {
        console.log(`[SUCCESS] Preserved loading times for wagon tower_number=${w.tower_number}, indent_number=${indentNum}: start=${loadingStartTime || 'null'}, end=${loadingEndTime || 'null'}`);
      }

      await pool.query(
        `
      INSERT INTO wagon_records (
        train_id,
        rake_serial_number,
        wagon_number,
        wagon_type,
        cc_weight,
        sick_box,
        wagon_to_be_loaded,
        tower_number,
        loaded_bag_count,
        unloaded_bag_count,
        loading_start_time,
        loading_end_time,
        seal_number,
        stoppage_time,
        remarks,
        loading_status,
        indent_number,
        wagon_destination,
        commodity,
        customer_id
      )
      VALUES (
        $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20
      )
      `,
        [
          actualTrainId,
          wagonRakeSerialNumber, // ✅ FIX: Use indent-specific rake_serial_number
          w.wagon_number || null,
          w.wagon_type || null,
          w.cc_weight || null,
          w.sick_box === "Yes",
          w.wagon_to_be_loaded || null,
          w.tower_number,
          loadedBagCount,
          unloadedBagCount,
          loadingStartTime,
          loadingEndTime,
          w.seal_number || null,
          w.stoppage_time || 0,
          w.remarks || null,
          loadingStatus,
          w.indent_number || header.indent_number || null,
          w.wagon_destination || null,
          w.commodity || null,
          w.customer_id || null,
        ]
      );

    }

    /* ===============================
       4️⃣ CHECK FOR SEQUENTIAL NUMBER ASSIGNMENT (when bag counting starts)
       =============================== */
    /* ===============================
       4️⃣ CHECK FOR DYNAMIC SERIAL NUMBER ASSIGNMENT (when bag counting starts)
       =============================== */
    // Track updated train_ids to return in response
    const updatedTrainIds = {};

    // Only process if has_sequential_serials is true (user selected "Multiple Rake Serial Number")
    console.log(`[DYNAMIC ASSIGN] Checking for dynamic assignment. hasSequentialSerials: ${hasSequentialSerials}, singleIndent: ${singleIndent}`);
    if (hasSequentialSerials && !singleIndent) {
      // ✅ FIX: Only run dynamic assignment if bag counting has JUST STARTED
      // Get existing wagon bag counts from database to detect if counting just started
      const existingBagCountsRes = await pool.query(
        `SELECT tower_number, indent_number, loaded_bag_count 
         FROM wagon_records 
         WHERE (train_id = $1 OR rake_serial_number = $1) 
         AND indent_number IS NOT NULL 
         AND indent_number != ''`,
        [actualTrainId]
      );
      
      // Create a map of existing bag counts by tower_number + indent_number
      const existingBagCountsMap = {};
      existingBagCountsRes.rows.forEach(row => {
        const key = `${row.tower_number}_${row.indent_number}`;
        existingBagCountsMap[key] = Number(row.loaded_bag_count || 0);
      });

      // Check if ANY wagon has JUST started counting (0 -> > 0 transition)
      let hasNewBagCountingStart = false;
      for (const w of wagons) {
        const indentNum = w.indent_number || header.indent_number;
        if (!indentNum) continue;
        
        const key = `${w.tower_number}_${indentNum}`;
        const existingCount = existingBagCountsMap[key] || 0;
        const newCount = Number(w.loaded_bag_count || 0);
        
        // Detect if bag counting just started (was 0, now > 0)
        if (existingCount === 0 && newCount > 0) {
          hasNewBagCountingStart = true;
          console.log(`[DYNAMIC ASSIGN] Detected bag counting start: wagon tower_number=${w.tower_number}, indent_number=${indentNum}, count: ${existingCount} -> ${newCount}`);
          break;
        }
      }

      // ✅ FIX: Only proceed with dynamic assignment if bag counting has JUST STARTED
      if (!hasNewBagCountingStart) {
        console.log(`[DYNAMIC ASSIGN] No new bag counting start detected. Skipping dynamic assignment.`);
        // Skip the entire dynamic assignment block
      } else {
        // Get all distinct indent numbers from the wagons we just saved
        const savedIndentNumbers = [...new Set(
          wagons.map(w => w.indent_number || header.indent_number).filter(Boolean)
        )];
        console.log(`[DYNAMIC ASSIGN] Indents to process: ${savedIndentNumbers.join(', ')}`);

        // First, get all indents that have already started counting (from database)
        // This helps us determine which indent was truly the first
        const allStartedIndentsRes = await pool.query(
          `SELECT DISTINCT indent_number FROM wagon_records 
           WHERE (train_id = $1 OR rake_serial_number = $1)
           AND indent_number IS NOT NULL
           AND indent_number != ''
           AND loaded_bag_count > 0`,
          [actualTrainId]
        );
        const dbStartedIndents = new Set(allStartedIndentsRes.rows.map(r => r.indent_number));

        // Also check which indents in the current batch have started counting
        const currentBatchStartedIndents = savedIndentNumbers.filter(indentNum => {
          const indentWagons = wagons.filter(w => (w.indent_number || header.indent_number) === indentNum);
          return indentWagons.some(w => Number(w.loaded_bag_count || 0) > 0);
        });

        // Combine database and current batch to get all started indents
        currentBatchStartedIndents.forEach(indent => dbStartedIndents.add(indent));
        const allStartedIndents = Array.from(dbStartedIndents);

        console.log(`[DYNAMIC ASSIGN] All started indents (DB + current batch): ${allStartedIndents.join(', ')}`);

        // Track which indent was the first to start counting (it keeps the original rake serial number)
        let firstStarterIndent = allStartedIndents.length > 0 ? allStartedIndents[0] : null;

        for (const indentNum of savedIndentNumbers) {
          // Check if this indent has any wagon with loaded_bag_count > 0 (counting started)
          const indentWagons = wagons.filter(w => (w.indent_number || header.indent_number) === indentNum);
          const hasCountingStarted = indentWagons.some(w => Number(w.loaded_bag_count || 0) > 0);
        
        // ✅ FIX: Check if loading is already completed for this indent
        // If all wagons are completed, don't reassign rake_serial_number
        const allWagonsCompleted = indentWagons.length > 0 && indentWagons.every(w => {
          const wagonToBeLoaded = w.wagon_to_be_loaded != null && w.wagon_to_be_loaded !== "" ? Number(w.wagon_to_be_loaded) : null;
          const loadedBagCount = Number(w.loaded_bag_count || 0);
          return wagonToBeLoaded != null ? (loadedBagCount >= wagonToBeLoaded && loadedBagCount > 0) : false;
        });
        
        // Also check database for completed status
        let dbAllWagonsCompleted = false;
        try {
          const dbWagonsRes = await pool.query(
            `SELECT COUNT(*) as total, 
                    SUM(CASE WHEN wagon_to_be_loaded IS NOT NULL 
                             AND loaded_bag_count >= wagon_to_be_loaded 
                             AND loaded_bag_count > 0 THEN 1 ELSE 0 END) as completed
             FROM wagon_records 
             WHERE (train_id = $1 OR rake_serial_number = $1) AND indent_number = $2`,
            [actualTrainId, indentNum]
          );
          if (dbWagonsRes.rows.length > 0) {
            const total = Number(dbWagonsRes.rows[0].total) || 0;
            const completed = Number(dbWagonsRes.rows[0].completed) || 0;
            dbAllWagonsCompleted = total > 0 && completed === total;
          }
        } catch (err) {
          console.error(`[DYNAMIC ASSIGN] Error checking completion status for indent ${indentNum}:`, err);
        }
        
        const isFullyCompleted = allWagonsCompleted || dbAllWagonsCompleted;
        
        if (isFullyCompleted) {
          console.log(`[DYNAMIC ASSIGN] Indent ${indentNum} is fully completed. Skipping rake_serial_number reassignment.`);
          continue; // Skip reassignment for completed indents
        }

        if (hasCountingStarted) {
          // Check if this indent is still using the shared base train_id (hasn't been split yet)
          // Get current rake serial number and train_id for this indent
          const currentIndentRecord = await pool.query(
            "SELECT train_id, rake_serial_number FROM dashboard_records WHERE (train_id = $1 OR rake_serial_number = $1) AND indent_number = $2 LIMIT 1",
            [actualTrainId, indentNum]
          );

          if (currentIndentRecord.rows.length === 0) {
            console.log(`[DYNAMIC ASSIGN] Indent ${indentNum} not found in dashboard_records, skipping`);
            continue;
          }

          const currentRecord = currentIndentRecord.rows[0];
          const currentRakeSerialNumber = currentRecord.rake_serial_number;
          const currentTrainIdForIndent = currentRecord.train_id;

          // Get the base rake serial number from the original train
          const baseTrainRecord = await pool.query(
            "SELECT rake_serial_number FROM train_session WHERE train_id = $1 OR rake_serial_number = $1 LIMIT 1",
            [actualTrainId]
          );
          const baseRakeSerialNumber = baseTrainRecord.rows[0]?.rake_serial_number || currentRakeSerialNumber;

          // Determine if this is the first starter
          // First starter is the one that appears first in the list of all started indents
          const isFirstStarter = indentNum === firstStarterIndent;
          
          if (isFirstStarter) {
            // This is the FIRST indent to start counting - it keeps the original rake serial number
            console.log(`[DYNAMIC ASSIGN] Indent ${indentNum} is the FIRST starter. Keeping original rake serial number: ${baseRakeSerialNumber}`);
            
            // Even if train_id is different, ensure rake_serial_number matches the base
            if (currentRakeSerialNumber !== baseRakeSerialNumber) {
              console.log(`[DYNAMIC ASSIGN] Updating rake_serial_number for first starter ${indentNum} to match base: ${baseRakeSerialNumber}`);
              await pool.query(
                `UPDATE dashboard_records
                 SET rake_serial_number = $1
                 WHERE train_id = $2 AND indent_number = $3`,
                [baseRakeSerialNumber, currentTrainIdForIndent, indentNum]
              );
            }
          } else {
            // This is a SUBSEQUENT indent (second, third, etc.) - needs unique rake serial number
            console.log(`[DYNAMIC ASSIGN] Indent ${indentNum} is a subsequent starter. Current rake serial: ${currentRakeSerialNumber}. Finding unique number.`);

            // Use the base rake serial number as starting point if current is same as base or null
            const startingRakeSerialNumber = (currentRakeSerialNumber && currentRakeSerialNumber !== baseRakeSerialNumber) 
              ? currentRakeSerialNumber 
              : baseRakeSerialNumber;

            if (!startingRakeSerialNumber) {
              console.log(`[DYNAMIC ASSIGN] Warning: Indent ${indentNum} has no rake serial number, using generateTrainId()`);
              const newRakeSerialNumber = await generateTrainId();
              // Keep train_id the same (don't change it) - only update rake_serial_number
              const finalTrainId = actualTrainId;

              // Create new train_session
              const currentSessionRes = await pool.query(
                "SELECT wagon_count, siding FROM train_session WHERE train_id = $1 OR rake_serial_number = $1",
                [actualTrainId]
              );
              const currentSession = currentSessionRes.rows[0];
              const sidingForNew = preservedSiding || currentSession?.siding;
              const wagonCountForNew = currentSession?.wagon_count || 0;

              // No need to create new train_session - train_id stays the same
              // Only update rake_serial_number in dashboard_records
              await pool.query(
                `UPDATE dashboard_records
                 SET rake_serial_number = $1
                 WHERE (train_id = $2 OR train_id = $3) AND indent_number = $4`,
                [newRakeSerialNumber, actualTrainId, currentTrainIdForIndent, indentNum]
              );

              // No need to update wagon_records or dispatch_records - train_id stays the same
              // Only rake_serial_number changes

              console.log(`[DYNAMIC ASSIGN] Assigned new rake serial number ${newRakeSerialNumber} to indent ${indentNum} (train_id kept as ${actualTrainId})`);
              updatedTrainIds[indentNum] = actualTrainId;
            } else {
              // Get next unique rake serial number by incrementing from starting point
              const newRakeSerialNumber = await generateNextUniqueRakeSerialNumber(startingRakeSerialNumber);
              // Keep train_id the same (don't change it) - only update rake_serial_number
              // No need to create new train_session - train_id stays the same
              // Only update rake_serial_number in dashboard_records
              await pool.query(
                `UPDATE dashboard_records
                 SET rake_serial_number = $1
                 WHERE (train_id = $2 OR train_id = $3) AND indent_number = $4`,
                [newRakeSerialNumber, actualTrainId, currentTrainIdForIndent, indentNum]
              );

              // No need to update wagon_records or dispatch_records - train_id stays the same
              // Only rake_serial_number changes

              console.log(`[DYNAMIC ASSIGN] Assigned unique rake serial number ${newRakeSerialNumber} to indent ${indentNum} (incremented from ${startingRakeSerialNumber}, train_id kept as ${actualTrainId})`);
              updatedTrainIds[indentNum] = actualTrainId;
            }
          }
        }
      }
      } // End of hasNewBagCountingStart check
    }

    // ✅ FIX: Add activity timeline entry for reviewer changes (only if there are actual changes)
    if (reviewerUsername && (userRole === "REVIEWER" || userRole === "ADMIN") && existingHeaders.length > 0) {
      // ✅ FIX: Fetch customer names for customer_id lookups
      const customerMap = new Map();
      try {
        const customerRes = await pool.query("SELECT id, customer_name FROM customers");
        customerRes.rows.forEach(row => {
          customerMap.set(String(row.id), row.customer_name);
        });
      } catch (err) {
        console.error("Error fetching customers for activity timeline:", err);
      }

      // Compare header changes
      const headerChanges = [];
      if (existingHeaders.length > 0) {
        const existingHeader = existingHeaders[0];
        const headerFieldNames = {
          indent_number: "Indent Number",
          customer_id: "Customer Name",
          wagon_destination: "Wagon Destination",
          commodity: "Commodity",
        };

        for (const [field, displayName] of Object.entries(headerFieldNames)) {
          let oldValue = existingHeader[field] != null ? String(existingHeader[field]) : "";
          let newValue = header[field] != null ? String(header[field]) : "";

          // ✅ FIX: Convert customer_id to customer name
          if (field === "customer_id") {
            oldValue = oldValue && customerMap.has(oldValue) ? customerMap.get(oldValue) : (oldValue || "");
            newValue = newValue && customerMap.has(newValue) ? customerMap.get(newValue) : (newValue || "");
          }

          if (oldValue !== newValue) {
            headerChanges.push({
              field: displayName,
              oldValue: oldValue || "(empty)",
              newValue: newValue || "(empty)",
            });
          }
        }
      }

      // Compare wagon changes
      const wagonChanges = [];
      
      // Build multiple maps for robust matching
      const existingWagonsByTowerNumber = new Map();
      const existingWagonsByIndex = new Map();
      const existingWagonsByWagonNumber = new Map();
      
      // Build maps of existing wagons using multiple criteria
      existingWagons.forEach((w, idx) => {
        // Map by tower_number (primary key)
        if (w.tower_number != null) {
          existingWagonsByTowerNumber.set(String(w.tower_number), w);
        }
        // Map by index (fallback)
        existingWagonsByIndex.set(String(idx), w);
        // Map by wagon_number (additional fallback)
        if (w.wagon_number != null && w.wagon_number !== '') {
          existingWagonsByWagonNumber.set(String(w.wagon_number).trim(), w);
        }
      });

      // Debug: Log existing wagons details
      console.log(`[ACTIVITY TIMELINE] Existing wagons count: ${existingWagons.length}, New wagons count: ${wagons.length}`);
      existingWagons.forEach((w, idx) => {
        console.log(`[ACTIVITY TIMELINE] Existing wagon ${idx}: tower_number=${w.tower_number}, wagon_number=${w.wagon_number}, cc_weight=${w.cc_weight}, indent_number=${w.indent_number}`);
      });
      
      // Debug: Log new wagons details
      wagons.forEach((w, idx) => {
        console.log(`[ACTIVITY TIMELINE] New wagon ${idx}: tower_number=${w.tower_number}, wagon_number=${w.wagon_number}, cc_weight=${w.cc_weight}, indent_number=${w.indent_number}`);
      });

      // Compare each wagon in the new data with existing data
      wagons.forEach((w, idx) => {
        let existingWagon = null;
        let matchMethod = '';
        
        // Try multiple matching strategies
        // 1. Try by tower_number (most reliable)
        if (w.tower_number != null) {
          existingWagon = existingWagonsByTowerNumber.get(String(w.tower_number));
          if (existingWagon) {
            matchMethod = 'tower_number';
          }
        }
        
        // 2. Try by index (fallback)
        if (!existingWagon) {
          existingWagon = existingWagonsByIndex.get(String(idx));
          if (existingWagon) {
            matchMethod = 'index';
          }
        }
        
        // 3. Try by wagon_number (additional fallback)
        if (!existingWagon && w.wagon_number != null && w.wagon_number !== '') {
          existingWagon = existingWagonsByWagonNumber.get(String(w.wagon_number).trim());
          if (existingWagon) {
            matchMethod = 'wagon_number';
          }
        }
        
        // Debug: Log matching result
        if (existingWagon) {
          console.log(`[ACTIVITY TIMELINE] Wagon ${idx} matched by ${matchMethod}: tower_number=${w.tower_number}, existing_tower_number=${existingWagon.tower_number}`);
        } else {
          console.log(`[ACTIVITY TIMELINE] Wagon ${idx} NOT FOUND in existing data: tower_number=${w.tower_number}, wagon_number=${w.wagon_number}, idx=${idx}`);
        }

        if (existingWagon) {
          // Compare wagon fields
          const wagonFieldNames = {
            wagon_number: "Wagon Number",
            wagon_type: "Wagon Type",
            cc_weight: "CC Weight",
            sick_box: "Sick Box",
            wagon_to_be_loaded: "Bags To Be Loaded",
            commodity: "Commodity",
            seal_number: "Seal Number",
            stoppage_time: "Stoppage Time",
            remarks: "Remarks",
            loading_status: "Loading Completed",
            wagon_destination: "Wagon Destination",
            customer_id: "Customer Name",
          };

          // Track all changes for this wagon
          const wagonChangesForThisWagon = [];

          for (const [field, displayName] of Object.entries(wagonFieldNames)) {
            let oldValue = existingWagon[field];
            let newValue = w[field];

            // Normalize values for comparison
            if (field === "sick_box") {
              oldValue = oldValue ? "Yes" : "No";
              newValue = newValue === "Yes" || newValue === true ? "Yes" : "No";
            } else if (field === "loading_status") {
              oldValue = oldValue ? "Yes" : "No";
              newValue = newValue ? "Yes" : "No";
            } else if (field === "seal_number") {
              // Normalize seal numbers - trim and compare
              oldValue = oldValue != null ? String(oldValue).trim() : "";
              newValue = newValue != null ? String(newValue).trim() : "";
            } else if (field === "cc_weight" || field === "wagon_to_be_loaded") {
              // ✅ FIX: Normalize numeric fields - convert to numbers first, then to string for consistent comparison
              // Handle both number and string inputs
              const oldNum = oldValue != null ? (typeof oldValue === 'number' ? oldValue : parseFloat(String(oldValue).trim()) || 0) : 0;
              const newNum = newValue != null ? (typeof newValue === 'number' ? newValue : parseFloat(String(newValue).trim()) || 0) : 0;
              oldValue = isNaN(oldNum) ? "" : String(oldNum);
              newValue = isNaN(newNum) ? "" : String(newNum);
            } else {
              oldValue = oldValue != null ? String(oldValue).trim() : "";
              newValue = newValue != null ? String(newValue).trim() : "";
            }

            // ✅ FIX: Convert customer_id to customer name
            if (field === "customer_id") {
              oldValue = oldValue && customerMap.has(oldValue) ? customerMap.get(oldValue) : (oldValue || "");
              newValue = newValue && customerMap.has(newValue) ? customerMap.get(newValue) : (newValue || "");
            }

            if (oldValue !== newValue) {
              wagonChangesForThisWagon.push({
                field: displayName,
                oldValue: oldValue || "(empty)",
                newValue: newValue || "(empty)",
              });
              // Debug: Log field comparison
              console.log(`[ACTIVITY TIMELINE] Field change detected for Wagon ${w.tower_number != null ? w.tower_number : idx + 1}: ${displayName} - "${oldValue || "(empty)"}" → "${newValue || "(empty)"}"`);
            }
          }

          // Add all changes for this wagon to the main changes array
          if (wagonChangesForThisWagon.length > 0) {
            console.log(`[ACTIVITY TIMELINE] Found ${wagonChangesForThisWagon.length} change(s) for Wagon ${w.tower_number != null ? w.tower_number : idx + 1}`);
            wagonChangesForThisWagon.forEach(change => {
              const wagonLabel = `Wagon ${w.tower_number != null ? w.tower_number : idx + 1}`;
              wagonChanges.push({
                wagon: wagonLabel,
                field: change.field,
                oldValue: change.oldValue,
                newValue: change.newValue,
              });
              // Debug: Log each change detected
              console.log(`[ACTIVITY TIMELINE] Change detected: ${wagonLabel} - ${change.field}: "${change.oldValue}" → "${change.newValue}"`);
            });
          } else {
            console.log(`[ACTIVITY TIMELINE] No changes detected for Wagon ${w.tower_number != null ? w.tower_number : idx + 1}`);
          }
        } else {
          // New wagon added
          wagonChanges.push({
            wagon: `Wagon ${w.tower_number != null ? w.tower_number : idx + 1}`,
            field: "Status",
            oldValue: "(empty)",
            newValue: "Added",
          });
        }
      });

      // Check for deleted wagons (wagons that existed but are no longer in the new data)
      // Create a set of matched existing wagons
      const matchedExistingWagons = new Set();
      wagons.forEach((w, idx) => {
        // Mark existing wagons that were matched
        let existingWagon = null;
        if (w.tower_number != null) {
          existingWagon = existingWagonsByTowerNumber.get(String(w.tower_number));
        }
        if (!existingWagon) {
          existingWagon = existingWagonsByIndex.get(String(idx));
        }
        if (!existingWagon && w.wagon_number != null && w.wagon_number !== '') {
          existingWagon = existingWagonsByWagonNumber.get(String(w.wagon_number).trim());
        }
        if (existingWagon) {
          // Mark this existing wagon as matched
          matchedExistingWagons.add(existingWagon);
        }
      });

      // Find existing wagons that weren't matched (deleted)
      existingWagons.forEach((w, idx) => {
        if (!matchedExistingWagons.has(w)) {
          wagonChanges.push({
            wagon: `Wagon ${w.tower_number != null ? w.tower_number : idx + 1}`,
            field: "Status",
            oldValue: "Exists",
            newValue: "Deleted",
          });
          console.log(`[ACTIVITY TIMELINE] Wagon deleted: Wagon ${w.tower_number != null ? w.tower_number : idx + 1}`);
        }
      });

      // Debug: Log summary of all detected changes
      console.log(`[ACTIVITY TIMELINE] Summary: ${headerChanges.length} header change(s), ${wagonChanges.length} wagon change(s) detected`);

      // ✅ FIX: Only log to activity timeline if there are actual changes
      if (headerChanges.length > 0 || wagonChanges.length > 0) {
        const changeDescriptions = [];

        if (headerChanges.length > 0) {
          const headerDesc = headerChanges.map(c =>
            `${c.field}: "${c.oldValue}" → "${c.newValue}"`
          ).join("; ");
          changeDescriptions.push(`Header: ${headerDesc}`);
        }

        if (wagonChanges.length > 0) {
          // Group wagon changes by wagon
          const wagonGroups = {};
          wagonChanges.forEach(c => {
            if (!wagonGroups[c.wagon]) {
              wagonGroups[c.wagon] = [];
            }
            wagonGroups[c.wagon].push(`${c.field}: "${c.oldValue}" → "${c.newValue}"`);
          });

          const wagonDesc = Object.entries(wagonGroups).map(([wagon, changes]) =>
            `${wagon} (${changes.join("; ")})`
          ).join(" | ");
          changeDescriptions.push(`Wagons: ${wagonDesc}`);
          
          // Debug: Log grouped changes
          console.log(`[ACTIVITY TIMELINE] Grouped wagon changes:`, Object.keys(wagonGroups).map(w => `${w}: ${wagonGroups[w].length} change(s)`).join(', '));
        }

        // Store change details in structured format for Excel export
        const changeDetails = {
          headerChanges: headerChanges,
          wagonChanges: wagonChanges,
          timestamp: new Date().toISOString()
        };
        
        // Store both human-readable notes and structured change details as JSON
        const notes = `Reviewer made changes: ${changeDescriptions.join(" | ")}`;
        const changeDetailsJson = JSON.stringify(changeDetails);
        
        // Store notes with change details JSON appended (separated by special marker)
        const notesWithDetails = `${notes}|||CHANGE_DETAILS:${changeDetailsJson}`;

        // Determine indent_number for activity timeline
        const indentNumForTimeline = singleIndent
          ? (header.indent_number || null)
          : (wagons.length > 0 ? (wagons[0].indent_number || null) : null);

        await addActivityTimelineEntry(
          actualTrainId,
          indentNumForTimeline,
          'REVIEWER_TRAIN_EDITED',
          reviewerUsername,
          notesWithDetails
        );
      }
      // ✅ FIX: Don't log if there are no changes (user only wants edited fields watched)
    }

    // Return updated train_ids if any sequential numbers were assigned
    const response = { message: "Draft saved successfully" };
    if (Object.keys(updatedTrainIds).length > 0) {
      response.updatedTrainIds = updatedTrainIds;
      response.trainIdChanged = true;
    }

    res.json(response);
  } catch (err) {
    console.error("SAVE DRAFT ERROR:", err);
    res.status(500).json({ message: "Failed to save draft" });
  }
});


app.get("/train/:trainId/dispatch", async (req, res) => {
  const { trainId } = req.params;
  // trainId may be URL encoded (e.g., "2025-26%2F02%2F001"), decode it
  const decodedTrainId = decodeURIComponent(trainId);
  const indentNumber = req.query.indent_number; // Support Case 2: multiple indents with same train_id

  try {
    // ✅ FIX: First, resolve the actual train_id from train_session or dashboard_records
    // The URL trainId might be either train_id or rake_serial_number
    const trainSessionRes = await pool.query(
      "SELECT train_id, rake_serial_number FROM train_session WHERE train_id = $1 OR rake_serial_number = $1 LIMIT 1",
      [decodedTrainId]
    );
    
    // Get the actual train_id - prefer from train_session, otherwise check dashboard_records
    let actualTrainId = trainSessionRes.rows[0]?.train_id || null;
    
    // If not found in train_session, check dashboard_records
    if (!actualTrainId) {
      const dashboardCheck = await pool.query(
        "SELECT train_id, rake_serial_number FROM dashboard_records WHERE train_id = $1 OR rake_serial_number = $1 ORDER BY CASE WHEN train_id = rake_serial_number THEN 1 ELSE 0 END, train_id LIMIT 1",
        [decodedTrainId]
      );
      if (dashboardCheck.rows.length > 0) {
        // Prefer the train_id that's different from rake_serial_number (parent record)
        actualTrainId = dashboardCheck.rows[0].train_id || decodedTrainId;
      } else {
        actualTrainId = decodedTrainId; // Fallback to URL trainId if not found
      }
    }

    // Get dashboard record for this train (and optionally indent_number)
    // Check both train_id and rake_serial_number since URL might use either
    // ✅ FIX: Also get rake_serial_number to return in response
    // ✅ FIX: Also check the original decodedTrainId in case it's a rake_serial_number
    let headerQuery, headerParams;
    if (indentNumber) {
      // Check both actualTrainId and decodedTrainId to handle cases where URL is rake_serial_number
      if (actualTrainId !== decodedTrainId) {
        headerQuery = `SELECT siding, indent_number, rake_serial_number FROM dashboard_records WHERE ((train_id=$1 OR rake_serial_number=$1) OR (train_id=$3 OR rake_serial_number=$3)) AND indent_number=$2 LIMIT 1`;
        headerParams = [actualTrainId, indentNumber, decodedTrainId];
      } else {
        headerQuery = `SELECT siding, indent_number, rake_serial_number FROM dashboard_records WHERE (train_id=$1 OR rake_serial_number=$1) AND indent_number=$2 LIMIT 1`;
        headerParams = [actualTrainId, indentNumber];
      }
    } else {
      // Get first available dashboard record (prefer null/empty indent_number, then first by indent_number)
      // Check both actualTrainId and decodedTrainId
      if (actualTrainId !== decodedTrainId) {
        headerQuery = `
          SELECT siding, indent_number, rake_serial_number 
          FROM dashboard_records 
          WHERE (train_id=$1 OR rake_serial_number=$1) OR (train_id=$2 OR rake_serial_number=$2)
          ORDER BY 
            CASE WHEN indent_number IS NULL OR indent_number = '' THEN 0 ELSE 1 END,
            indent_number
          LIMIT 1
        `;
        headerParams = [actualTrainId, decodedTrainId];
      } else {
        headerQuery = `
          SELECT siding, indent_number, rake_serial_number 
          FROM dashboard_records 
          WHERE train_id=$1 OR rake_serial_number=$1
          ORDER BY 
            CASE WHEN indent_number IS NULL OR indent_number = '' THEN 0 ELSE 1 END,
            indent_number
          LIMIT 1
        `;
        headerParams = [actualTrainId];
      }
    }

    const headerRes = await pool.query(headerQuery, headerParams);

    if (headerRes.rows.length === 0) {
      return res.status(404).json({ message: "Train not found" });
    }

    // Get the indent_number from the dashboard record (this is the source of truth)
    const dashboardIndentNumber = headerRes.rows[0].indent_number;

    // Get dispatch record matching the dashboard record's indent_number
    // ✅ FIX: Use both train_id and rake_serial_number for dispatch queries
    let dispatchQuery, dispatchParams;
    if (dashboardIndentNumber && dashboardIndentNumber !== null && dashboardIndentNumber !== '') {
      // Match dispatch record with the same indent_number as dashboard record
      dispatchQuery = `SELECT * FROM dispatch_records WHERE (train_id=$1 OR rake_serial_number=$1) AND indent_number=$2`;
      dispatchParams = [actualTrainId, dashboardIndentNumber];
    } else {
      // Dashboard has no indent_number, so look for dispatch with null/empty indent_number
      dispatchQuery = `SELECT * FROM dispatch_records WHERE (train_id=$1 OR rake_serial_number=$1) AND (indent_number IS NULL OR indent_number = '')`;
      dispatchParams = [actualTrainId];
    }

    let dispatchRes = await pool.query(dispatchQuery, dispatchParams);

    // If no dispatch record found with matching indent_number, try to find any dispatch record
    if (dispatchRes.rows.length === 0) {
      dispatchQuery = `
        SELECT * FROM dispatch_records 
        WHERE (train_id=$1 OR rake_serial_number=$1)
        ORDER BY 
          CASE WHEN indent_number IS NULL OR indent_number = '' THEN 0 ELSE 1 END,
          indent_number
        LIMIT 1
      `;
      dispatchParams = [actualTrainId];
      dispatchRes = await pool.query(dispatchQuery, dispatchParams);
    }

    // If this is a child serial number (e.g., 2024-25/01/001-1) and no dispatch records exist,
    // check if parent has dispatch records and copy them
    // Pattern: financial_year/month/sequence-sequential (e.g., 2024-25/01/001-1)
    if (dispatchRes.rows.length === 0 && actualTrainId.match(/^(.+\/\d+\/\d+)-(\d+)$/)) {
      const parentTrainId = actualTrainId.replace(/-(\d+)$/, '');

      const parentDispatchRes = await pool.query(
        `SELECT * FROM dispatch_records WHERE (train_id=$1 OR rake_serial_number=$1)`,
        [parentTrainId]
      );

      if (parentDispatchRes.rows.length > 0) {
        // Get parent's rake_serial_number
        const parentRakeSerial = parentDispatchRes.rows[0].rake_serial_number;
        // Get child's rake_serial_number
        let childRakeSerial = null;
        try {
          const childRakeRes = await pool.query(
            "SELECT rake_serial_number FROM train_session WHERE train_id = $1 LIMIT 1",
            [actualTrainId]
          );
          childRakeSerial = childRakeRes.rows[0]?.rake_serial_number || null;
        } catch (err) {
          console.error("Error getting child rake_serial_number:", err);
        }

        // Copy dispatch records from parent to child
        await pool.query(
          `
          INSERT INTO dispatch_records (
            train_id, rake_serial_number, source, indent_wagon_count, vessel_name, rake_type,
            rake_placement_datetime, rake_clearance_datetime, rake_idle_time,
            loading_start_officer, loading_completion_officer, remarks, status
          )
          SELECT 
            $1, $2, source, indent_wagon_count, vessel_name, rake_type,
            rake_placement_datetime, rake_clearance_datetime, rake_idle_time,
            loading_start_officer, loading_completion_officer, remarks, status
          FROM dispatch_records
          WHERE (train_id = $3 OR rake_serial_number = $3)
          `,
          [actualTrainId, childRakeSerial, parentTrainId]
        );

        // Re-fetch the newly created dispatch record
        dispatchRes = await pool.query(
          `SELECT * FROM dispatch_records WHERE (train_id=$1 OR rake_serial_number=$1)`,
          [actualTrainId]
        );
      }
    }

    // Get wagon data to calculate auto-populated fields
    // Filter by indent_number if provided, order by tower_number
    // ✅ FIX: Use both train_id and rake_serial_number for wagon queries
    // Get rake_serial_number for queries
    let actualRakeSerialNumber = null;
    try {
      const rakeSerialRes = await pool.query(
        "SELECT rake_serial_number FROM train_session WHERE train_id = $1 OR rake_serial_number = $1 LIMIT 1",
        [actualTrainId]
      );
      actualRakeSerialNumber = rakeSerialRes.rows[0]?.rake_serial_number || null;
    } catch (err) {
      console.error("Error getting rake_serial_number for dispatch:", err);
    }

    let wagonQuery, wagonParams;
    if (dashboardIndentNumber && dashboardIndentNumber !== null && dashboardIndentNumber !== '') {
      wagonQuery = `
        SELECT 
          loading_start_time,
          loading_end_time
        FROM wagon_records 
        WHERE (train_id=$1 OR rake_serial_number=$1) AND indent_number=$2
        ORDER BY tower_number ASC
      `;
      wagonParams = [actualTrainId, dashboardIndentNumber];
    } else {
      wagonQuery = `
        SELECT 
          loading_start_time,
          loading_end_time
        FROM wagon_records 
        WHERE (train_id=$1 OR rake_serial_number=$1)
        ORDER BY tower_number ASC
      `;
      wagonParams = [actualTrainId];
    }

    const wagonRes = await pool.query(wagonQuery, wagonParams);

    // Calculate first wagon's loading_start_time and last wagon's loading_end_time
    let firstLoadingStart = null;
    let lastLoadingEnd = null;

    if (wagonRes.rows.length > 0) {
      // First wagon's loading_start_time (ordered by tower_number)
      const firstWagon = wagonRes.rows.find(w => w.loading_start_time);
      if (firstWagon) {
        firstLoadingStart = firstWagon.loading_start_time;
      }

      // Last wagon's loading_end_time (ordered by tower_number)
      const reversedWagons = [...wagonRes.rows].reverse();
      const lastWagon = reversedWagons.find(w => w.loading_end_time);
      if (lastWagon) {
        lastLoadingEnd = lastWagon.loading_end_time;
      }
    }

    // Ensure siding is returned as empty string if null, matching indent_number behavior
    const siding = headerRes.rows[0]?.siding || "";
    // ✅ FIX: Get rake_serial_number from dashboard record (this is the correct one for this indent)
    const rakeSerialNumber = headerRes.rows[0]?.rake_serial_number || null;

    // Get dispatch data
    let dispatchData = dispatchRes.rows[0] || null;

    // Auto-populate fields from calculated wagon data
    // Initialize dispatchData if null
    if (!dispatchData) {
      dispatchData = {};
    }

    // Always use calculated values from wagon data (ordered by tower_number)
    // These will be saved to the database when draft/submit is called
    if (firstLoadingStart) {
      dispatchData.rake_loading_start_datetime = firstLoadingStart;
    }
    if (lastLoadingEnd) {
      dispatchData.rake_loading_end_actual = lastLoadingEnd;
    }

    console.log(`Dispatch load for ${actualTrainId} (URL: ${decodedTrainId}):`, {
      queryIndentNumber: indentNumber || 'none',
      dashboardIndentNumber: dashboardIndentNumber || 'none',
      hasSiding: !!siding,
      hasDispatch: !!dispatchData,
      dispatchKeys: dispatchData ? Object.keys(dispatchData) : [],
      dispatchIndentNumber: dispatchData?.indent_number || 'none',
      hasUserInputFields: dispatchData ? !!(
        dispatchData.vessel_name ||
        dispatchData.rake_type ||
        dispatchData.indent_wagon_count ||
        dispatchData.rake_placement_datetime ||
        dispatchData.rake_clearance_datetime ||
        dispatchData.rake_idle_time ||
        dispatchData.loading_start_officer ||
        dispatchData.loading_completion_officer ||
        dispatchData.remarks
      ) : false,
    });

    res.json({
      siding: siding,
      rake_serial_number: rakeSerialNumber, // ✅ FIX: Return actual rake_serial_number for this indent
      dispatch: dispatchData,
    });
  } catch (err) {
    console.error("DISPATCH LOAD ERROR:", err);
    res.status(500).json({ message: `Failed to load dispatch data: ${err.message}` });
  }
});

app.post(
  "/train/:trainId/dispatch/draft",
  allowRoles(["ADMIN", "REVIEWER", "SUPER_ADMIN"]),
  async (req, res) => {
    const { trainId } = req.params;
    // trainId may be URL encoded (e.g., "2025-26%2F02%2F001"), decode it
    const decodedTrainId = decodeURIComponent(trainId);
    // ✅ FIX: Normalize indent_number (treat null, undefined, and empty string consistently)
    const rawIndentNumber = req.query.indent_number || (req.body && req.body.indent_number) || null;
    const indentNumber = rawIndentNumber && rawIndentNumber.trim() !== "" ? rawIndentNumber.trim() : null;
    const data = req.body || {}; // partial fields only

    try {
      // ✅ FIX: First, resolve the actual train_id from train_session or dashboard_records
      // The URL trainId might be either train_id or rake_serial_number
      const trainSessionRes = await pool.query(
        "SELECT train_id, rake_serial_number FROM train_session WHERE train_id = $1 OR rake_serial_number = $1 LIMIT 1",
        [decodedTrainId]
      );
      
      // Get the actual train_id - prefer from train_session, otherwise check dashboard_records
      let actualTrainId = trainSessionRes.rows[0]?.train_id || null;
      
      // If not found in train_session, check dashboard_records
      if (!actualTrainId) {
        const dashboardCheck = await pool.query(
          "SELECT train_id FROM dashboard_records WHERE train_id = $1 OR rake_serial_number = $1 LIMIT 1",
          [decodedTrainId]
        );
        actualTrainId = dashboardCheck.rows[0]?.train_id || decodedTrainId; // Fallback to URL trainId if not found
      }

      // ✅ FIX: Get rake_serial_number for dispatch queries
      let actualRakeSerialNumber = trainSessionRes.rows[0]?.rake_serial_number || null;
      if (!actualRakeSerialNumber) {
        const dashboardCheck = await pool.query(
          "SELECT rake_serial_number FROM dashboard_records WHERE train_id = $1 OR rake_serial_number = $1 LIMIT 1",
          [actualTrainId]
        );
        actualRakeSerialNumber = dashboardCheck.rows[0]?.rake_serial_number || null;
      }

      // 1️⃣ Check if dispatch record exists for this train (and optionally indent_number)
      // ✅ FIX: Use both train_id and rake_serial_number for queries
      let existsQuery, existsParams;
      if (indentNumber) {
        existsQuery = "SELECT 1 FROM dispatch_records WHERE (train_id = $1 OR rake_serial_number = $1) AND indent_number = $2";
        existsParams = [actualTrainId, indentNumber];
      } else {
        existsQuery = "SELECT 1 FROM dispatch_records WHERE (train_id = $1 OR rake_serial_number = $1) AND (indent_number IS NULL OR indent_number = '')";
        existsParams = [actualTrainId];
      }

      const existsRes = await pool.query(existsQuery, existsParams);

      /* =====================================================
         INSERT (FIRST TIME ONLY)
      ===================================================== */
      if (existsRes.rows.length === 0) {
        // ✅ FIX: Fetch loading times from wagon_records instead of using request body
        // Auto-populated fields should NEVER come from frontend - always fetch from wagon_records
        let wagonTimeQuery, wagonTimeParams;
        if (indentNumber) {
          wagonTimeQuery = `
            SELECT 
              loading_start_time,
              loading_end_time
            FROM wagon_records 
            WHERE (train_id=$1 OR rake_serial_number=$1) AND indent_number=$2
            ORDER BY tower_number ASC
          `;
          wagonTimeParams = [actualTrainId, indentNumber];
        } else {
          wagonTimeQuery = `
            SELECT 
              loading_start_time,
              loading_end_time
            FROM wagon_records 
            WHERE (train_id=$1 OR rake_serial_number=$1)
            ORDER BY tower_number ASC
          `;
          wagonTimeParams = [actualTrainId];
        }

        const wagonTimeRes = await pool.query(wagonTimeQuery, wagonTimeParams);
        
        // Calculate times from wagon_records
        let calculatedRakeLoadingStart = null;
        let calculatedRakeLoadingEnd = null;
        
        if (wagonTimeRes.rows.length > 0) {
          // First wagon's loading_start_time (ordered by tower_number)
          const firstWagon = wagonTimeRes.rows.find(w => w.loading_start_time);
          if (firstWagon) {
            calculatedRakeLoadingStart = firstWagon.loading_start_time;
          }

          // Last wagon's loading_end_time (ordered by tower_number)
          const reversedWagons = [...wagonTimeRes.rows].reverse();
          const lastWagon = reversedWagons.find(w => w.loading_end_time);
          if (lastWagon) {
            calculatedRakeLoadingEnd = lastWagon.loading_end_time;
          }
        }

        await pool.query(
          `
          INSERT INTO dispatch_records (
            train_id,
            rake_serial_number,
            indent_number,
            source,
            indent_wagon_count,
            vessel_name,
            rake_type,
            rake_placement_datetime,
            rake_clearance_datetime,
            rake_idle_time,
            loading_start_officer,
            loading_completion_officer,
            remarks,
            rr_number,
            rake_loading_end_railway,
            rake_loading_start_datetime,
            rake_loading_end_actual,
            status
          ) VALUES (
            $1,$2,$3,
            'KSLK',
            $4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,
            'DRAFT'
          )
          `,
          [
            actualTrainId,
            actualRakeSerialNumber,
            indentNumber,
            data.indent_wagon_count || null,
            data.vessel_name || null,
            data.rake_type || null,
            data.rake_placement_datetime || null,
            data.rake_clearance_datetime || null,
            data.rake_idle_time || null,
            data.loading_start_officer || null,
            data.loading_completion_officer || null,
            data.remarks || null,
            data.rr_number || null,
            data.rake_loading_end_railway || null,
            calculatedRakeLoadingStart, // ✅ FIX: Use calculated value from wagon_records, not from request
            calculatedRakeLoadingEnd, // ✅ FIX: Use calculated value from wagon_records, not from request
          ]
        );

        return res.json({ message: "Dispatch draft created successfully" });
      }

      /* =====================================================
         GET CURRENT VALUES FOR CHANGE TRACKING
      ===================================================== */
      // ✅ FIX: Get current dispatch record to track changes made by reviewer
      // Use actualTrainId for all queries
      let currentRecordQuery, currentRecordParams;
      if (indentNumber) {
        currentRecordQuery = `
          SELECT indent_wagon_count, vessel_name, rake_type, rake_placement_datetime,
                 rake_clearance_datetime, rake_idle_time, loading_start_officer,
                 loading_completion_officer, remarks, rr_number, rake_loading_end_railway,
                 rake_loading_start_datetime, rake_loading_end_actual
          FROM dispatch_records
          WHERE (train_id = $1 OR rake_serial_number = $1) AND indent_number = $2
        `;
        currentRecordParams = [actualTrainId, indentNumber];
      } else {
        currentRecordQuery = `
          SELECT indent_wagon_count, vessel_name, rake_type, rake_placement_datetime,
                 rake_clearance_datetime, rake_idle_time, loading_start_officer,
                 loading_completion_officer, remarks, rr_number, rake_loading_end_railway,
                 rake_loading_start_datetime, rake_loading_end_actual
          FROM dispatch_records
          WHERE (train_id = $1 OR rake_serial_number = $1) AND (indent_number IS NULL OR indent_number = '')
        `;
        currentRecordParams = [actualTrainId];
      }

      const currentRecordRes = await pool.query(currentRecordQuery, currentRecordParams);
      const currentRecord = currentRecordRes.rows[0] || {};

      /* =====================================================
         DYNAMIC UPDATE (ONLY CHANGED FIELDS)
      ===================================================== */
      // ✅ FIX: Exclude auto-populated fields (rake_loading_start_datetime, rake_loading_end_actual)
      // These fields are calculated from wagon_records and should NEVER be updated by frontend saves
      const allowedFields = [
        "indent_wagon_count",
        "vessel_name",
        "rake_type",
        "rake_placement_datetime",
        "rake_clearance_datetime",
        "rake_idle_time",
        "loading_start_officer",
        "loading_completion_officer",
        "remarks",
        "rr_number",
        "rake_loading_end_railway",
        // ✅ FIX: Removed rake_loading_start_datetime and rake_loading_end_actual - these are auto-populated
      ];

      // Field display names for activity timeline
      const fieldDisplayNames = {
        "indent_wagon_count": "Indent Wagon Count",
        "vessel_name": "Vessel Name",
        "rake_type": "Rake Type",
        "rake_placement_datetime": "Rake Placement Date & Time",
        "rake_clearance_datetime": "Rake Clearance Time",
        "rake_idle_time": "Rake Idle Time",
        "loading_start_officer": "Loading Start Officer",
        "loading_completion_officer": "Loading Completion Officer",
        "remarks": "Remarks",
        "rr_number": "RR Number",
        "rake_loading_end_railway": "Rake Loading End Date & Time Railway",
        // ✅ FIX: Removed auto-populated fields from display names
      };

      const updates = [];
      const values = [];
      let index = 1;
      const changes = [];

      for (const field of allowedFields) {
        if (field in data) {
          const oldValue = currentRecord[field];
          // ✅ FIX: Preserve empty strings as empty strings, only convert undefined/null to null
          // This ensures that if a field is explicitly set to empty string, it's preserved
          // Only convert to null if the value is actually null or undefined
          let newValue = data[field];
          if (newValue === undefined || newValue === null) {
            newValue = null;
          } else if (typeof newValue === 'string' && newValue.trim() === '') {
            // Empty string - keep as null in database (consistent with existing behavior)
            newValue = null;
          }

          // Track changes (compare as strings to handle null/empty)
          const oldValStr = oldValue != null ? String(oldValue).trim() : "";
          const newValStr = newValue != null ? String(newValue).trim() : "";

          if (oldValStr !== newValStr) {
            changes.push({
              field: fieldDisplayNames[field] || field,
              oldValue: oldValStr || "(empty)",
              newValue: newValStr || "(empty)",
            });
          }

          // ✅ FIX: Only update if there's an actual change
          if (oldValStr !== newValStr) {
            updates.push(`${field} = $${index}`);
            values.push(newValue);
            index++;
          }
        }
      }

      // Get reviewer username if present
      const reviewerUsername = req.headers["x-reviewer-username"];

      // Always keep status as DRAFT on save
      updates.push(`status = 'DRAFT'`);

      values.push(actualTrainId);

      // Build WHERE clause with train_id/rake_serial_number and optionally indent_number
      // ✅ FIX: Use both train_id and rake_serial_number for queries
      let whereClause = `WHERE (train_id = $${index} OR rake_serial_number = $${index})`;
      if (indentNumber) {
        index++;
        whereClause += ` AND indent_number = $${index}`;
        values.push(indentNumber);
      } else {
        whereClause += ` AND (indent_number IS NULL OR indent_number = '')`;
      }

      const updateQuery = `
        UPDATE dispatch_records
        SET ${updates.join(", ")}
        ${whereClause}
      `;

      await pool.query(updateQuery, values);

      // ✅ FIX: Always update auto-populated fields from wagon_records after user fields are updated
      // This ensures loading times are always current, regardless of what frontend sends
      let wagonTimeQuery, wagonTimeParams;
      if (indentNumber) {
        wagonTimeQuery = `
          SELECT 
            loading_start_time,
            loading_end_time
          FROM wagon_records 
          WHERE (train_id=$1 OR rake_serial_number=$1) AND indent_number=$2
          ORDER BY tower_number ASC
        `;
        wagonTimeParams = [actualTrainId, indentNumber];
      } else {
        wagonTimeQuery = `
          SELECT 
            loading_start_time,
            loading_end_time
          FROM wagon_records 
          WHERE (train_id=$1 OR rake_serial_number=$1)
          ORDER BY tower_number ASC
        `;
        wagonTimeParams = [actualTrainId];
      }

      const wagonTimeRes = await pool.query(wagonTimeQuery, wagonTimeParams);
      
      // Calculate times from wagon_records
      let calculatedRakeLoadingStart = null;
      let calculatedRakeLoadingEnd = null;
      
      if (wagonTimeRes.rows.length > 0) {
        // First wagon's loading_start_time (ordered by tower_number)
        const firstWagon = wagonTimeRes.rows.find(w => w.loading_start_time);
        if (firstWagon) {
          calculatedRakeLoadingStart = firstWagon.loading_start_time;
        }

        // Last wagon's loading_end_time (ordered by tower_number)
        const reversedWagons = [...wagonTimeRes.rows].reverse();
        const lastWagon = reversedWagons.find(w => w.loading_end_time);
        if (lastWagon) {
          calculatedRakeLoadingEnd = lastWagon.loading_end_time;
        }
      }

      // Update auto-populated fields from wagon_records
      if (indentNumber) {
        await pool.query(
          `UPDATE dispatch_records 
           SET rake_loading_start_datetime = $1, rake_loading_end_actual = $2
           WHERE (train_id = $3 OR rake_serial_number = $3) AND indent_number = $4`,
          [calculatedRakeLoadingStart, calculatedRakeLoadingEnd, actualTrainId, indentNumber]
        );
      } else {
        await pool.query(
          `UPDATE dispatch_records 
           SET rake_loading_start_datetime = $1, rake_loading_end_actual = $2
           WHERE (train_id = $3 OR rake_serial_number = $3) AND (indent_number IS NULL OR indent_number = '')`,
          [calculatedRakeLoadingStart, calculatedRakeLoadingEnd, actualTrainId]
        );
      }

      // ✅ FIX: Add activity timeline entry for reviewer changes (only if there are actual changes)
      if (reviewerUsername && changes.length > 0) {
        // Format changes for activity timeline
        const changeDescriptions = changes.map(c =>
          `${c.field}: "${c.oldValue}" → "${c.newValue}"`
        ).join("; ");

        await addActivityTimelineEntry(
          trainId,
          indentNumber || null,
          'REVIEWER_EDITED',
          reviewerUsername,
          `Reviewer made changes: ${changeDescriptions}`
        );
      }
      // ✅ FIX: Don't log if there are no changes (user only wants edited fields watched)

      res.json({ message: "Dispatch draft updated successfully" });
    } catch (err) {
      console.error("DISPATCH DRAFT ERROR:", err);
      res.status(500).json({ message: "Failed to save dispatch draft" });
    }
  }
);




app.post(
  "/train/:trainId/dispatch/submit",
  allowRoles(["ADMIN", "SUPER_ADMIN"]),
  async (req, res) => {
    const { trainId } = req.params;
    // trainId may be URL encoded (e.g., "2025-26%2F02%2F001"), decode it
    const decodedTrainId = decodeURIComponent(trainId);
    const indentNumber = req.query.indent_number || (req.body && req.body.indent_number) || null; // Support Case 2
    const { rr_number, rake_loading_end_railway } = req.body || {}; // ✅ FIX: Only get user input fields, NOT auto-populated fields
    const username = req.body.username || req.headers["x-username"] || null; // Get username from body or header
    const role = req.headers["x-user-role"];

    try {
      // ✅ FIX: First, resolve the actual train_id from train_session or dashboard_records
      // The URL trainId might be either train_id or rake_serial_number
      const trainSessionRes = await pool.query(
        "SELECT train_id, rake_serial_number FROM train_session WHERE train_id = $1 OR rake_serial_number = $1 LIMIT 1",
        [decodedTrainId]
      );
      
      // Get the actual train_id - prefer from train_session, otherwise check dashboard_records
      let actualTrainId = trainSessionRes.rows[0]?.train_id || null;
      
      // If not found in train_session, check dashboard_records
      if (!actualTrainId) {
        const dashboardCheck = await pool.query(
          "SELECT train_id FROM dashboard_records WHERE train_id = $1 OR rake_serial_number = $1 LIMIT 1",
          [decodedTrainId]
        );
        actualTrainId = dashboardCheck.rows[0]?.train_id || decodedTrainId; // Fallback to URL trainId if not found
      }
      // Use user-provided rr_number if available; keep it NULL when empty (no auto-generate)
      const rrNumber = rr_number && rr_number.trim() !== ""
        ? rr_number.trim()
        : null;

      // Build update fields dynamically
      const updateFields = ["status='SUBMITTED'", "rr_number=$1", "submitted_by=$2", "submitted_at=NOW()"];
      const updateValues = [rrNumber, username];
      let paramIndex = 3;

      // Add rake_loading_end_railway if provided
      if (rake_loading_end_railway !== undefined && rake_loading_end_railway !== null) {
        updateFields.push(`rake_loading_end_railway=$${paramIndex}`);
        updateValues.push(rake_loading_end_railway || null);
        paramIndex++;
      }

      // ✅ FIX: DO NOT add auto-populated fields (rake_loading_start_datetime, rake_loading_end_actual) from request body
      // These will be fetched from wagon_records and updated separately

      // Update dispatch_records
      // ✅ FIX: Use both train_id and rake_serial_number for queries (matching sample pattern but with our dual-column support)
      let dispatchUpdateQuery, dispatchParams;
      if (indentNumber) {
        updateValues.push(actualTrainId);
        updateValues.push(indentNumber);
        dispatchUpdateQuery = `
          UPDATE dispatch_records SET
            ${updateFields.join(", ")}
          WHERE (train_id=$${paramIndex} OR rake_serial_number=$${paramIndex}) AND indent_number=$${paramIndex + 1}
        `;
        dispatchParams = updateValues;
      } else {
        updateValues.push(actualTrainId);
        dispatchUpdateQuery = `
          UPDATE dispatch_records SET
            ${updateFields.join(", ")}
          WHERE (train_id=$${paramIndex} OR rake_serial_number=$${paramIndex}) AND (indent_number IS NULL OR indent_number = '')
        `;
        dispatchParams = updateValues;
      }

      await pool.query(dispatchUpdateQuery, dispatchParams);

      // ✅ FIX: Always fetch latest loading times from wagon_records to ensure they're preserved
      // This ensures we always have the latest times from wagon_records, even if request doesn't include them
      // ✅ FIX: Use both train_id and rake_serial_number for queries
      let wagonTimeQuery, wagonTimeParams;
      if (indentNumber) {
        wagonTimeQuery = `
          SELECT 
            loading_start_time,
            loading_end_time
          FROM wagon_records 
          WHERE (train_id=$1 OR rake_serial_number=$1) AND indent_number=$2
          ORDER BY tower_number ASC
        `;
        wagonTimeParams = [actualTrainId, indentNumber];
      } else {
        wagonTimeQuery = `
          SELECT 
            loading_start_time,
            loading_end_time
          FROM wagon_records 
          WHERE (train_id=$1 OR rake_serial_number=$1)
          ORDER BY tower_number ASC
        `;
        wagonTimeParams = [actualTrainId];
      }

      const wagonTimeRes = await pool.query(wagonTimeQuery, wagonTimeParams);
      
      // ✅ FIX: Calculate times from wagon_records (always use these, never from request)
      let calculatedRakeLoadingStart = null;
      let calculatedRakeLoadingEnd = null;
      
      if (wagonTimeRes.rows.length > 0) {
        // First wagon's loading_start_time (ordered by tower_number)
        const firstWagon = wagonTimeRes.rows.find(w => w.loading_start_time);
        if (firstWagon) {
          calculatedRakeLoadingStart = firstWagon.loading_start_time;
        }

        // Last wagon's loading_end_time (ordered by tower_number)
        const reversedWagons = [...wagonTimeRes.rows].reverse();
        const lastWagon = reversedWagons.find(w => w.loading_end_time);
        if (lastWagon) {
          calculatedRakeLoadingEnd = lastWagon.loading_end_time;
        }
      }
      
      // ✅ FIX: Update dispatch_records with calculated times from wagon_records
      if (indentNumber) {
        await pool.query(
          `UPDATE dispatch_records 
           SET rake_loading_start_datetime = $1, rake_loading_end_actual = $2
           WHERE (train_id = $3 OR rake_serial_number = $3) AND indent_number = $4`,
          [calculatedRakeLoadingStart, calculatedRakeLoadingEnd, actualTrainId, indentNumber]
        );
      } else {
        await pool.query(
          `UPDATE dispatch_records 
           SET rake_loading_start_datetime = $1, rake_loading_end_actual = $2
           WHERE (train_id = $3 OR rake_serial_number = $3) AND (indent_number IS NULL OR indent_number = '')`,
          [calculatedRakeLoadingStart, calculatedRakeLoadingEnd, actualTrainId]
        );
      }
      
      // Log for debugging
      console.log(`[DISPATCH SUBMIT] Loading times for ${actualTrainId} (indent: ${indentNumber || 'none'}):`, {
        fromWagonRecords: {
          start: calculatedRakeLoadingStart,
          end: calculatedRakeLoadingEnd,
          wagonCount: wagonTimeRes.rows.length
        }
      });

      // Update dashboard_records based on role
      // Note: rake_loading_start_datetime and rake_loading_end_actual are calculated on-the-fly from wagon_records
      // in the dashboard query, so we don't need to store them in dashboard_records
      // ✅ FIX: Use actualTrainId and check both train_id and rake_serial_number to ensure correct record is updated
      let dashboardUpdateQuery, dashboardParams, activityType, activityNotes;
      if (role === "SUPER_ADMIN") {
        // SUPER_ADMIN: final approval, mark directly as APPROVED (Rake Loading Completed)
        if (indentNumber) {
          dashboardUpdateQuery = "UPDATE dashboard_records SET status='APPROVED' WHERE (train_id=$1 OR rake_serial_number=$1) AND indent_number=$2";
          dashboardParams = [actualTrainId, indentNumber];
        } else {
          dashboardUpdateQuery = "UPDATE dashboard_records SET status='APPROVED' WHERE (train_id=$1 OR rake_serial_number=$1)";
          dashboardParams = [actualTrainId];
        }
        activityType = 'APPROVED';
        activityNotes = 'Entry has been approved by SUPER_ADMIN';
      } else {
        // ADMIN: submit for reviewer approval
        if (indentNumber) {
          dashboardUpdateQuery = "UPDATE dashboard_records SET status='PENDING_APPROVAL' WHERE (train_id=$1 OR rake_serial_number=$1) AND indent_number=$2";
          dashboardParams = [actualTrainId, indentNumber];
        } else {
          dashboardUpdateQuery = "UPDATE dashboard_records SET status='PENDING_APPROVAL' WHERE (train_id=$1 OR rake_serial_number=$1)";
          dashboardParams = [actualTrainId];
        }
        activityType = 'SUBMITTED';
        activityNotes = 'Record submitted for review';
      }

      await pool.query(dashboardUpdateQuery, dashboardParams);
      
      // ✅ FIX: Ensure wagon times are preserved - verify they exist after submit
      // The dashboard calculates times from wagon_records, so we need to ensure wagon times are not cleared
      console.log(`[DISPATCH SUBMIT] Calculated times for ${actualTrainId} (indent: ${indentNumber || 'none'}):`, {
        rake_loading_start_datetime: calculatedRakeLoadingStart,
        rake_loading_end_actual: calculatedRakeLoadingEnd,
        source: "wagon_records" // ✅ FIX: Always from wagon_records, never from request
      });

      // Add activity timeline entry for submission/approval
      // ✅ FIX: Use actualTrainId instead of trainId
      if (username) {
        await addActivityTimelineEntry(
          actualTrainId,
          indentNumber || null,
          activityType,
          username,
          activityNotes
        );
      }

      res.json({ message: "Submitted successfully" });
    } catch (err) {
      console.error("DISPATCH SUBMIT ERROR:", err);
      res.status(500).json({ message: "Submit failed" });
    }
  }
);

/* =====================================================
   GET ACTIVITY TIMELINE
   ===================================================== */
app.get("/train/:trainId/activity-timeline", allowRoles(["ADMIN", "REVIEWER", "SUPER_ADMIN"]), async (req, res) => {
  const { trainId } = req.params;
  const indentNumber = req.query.indent_number || null;

  try {
    // ✅ FIX: Resolve actualTrainId and rake_serial_number for activity timeline queries
    const trainSessionRes = await pool.query(
      "SELECT train_id, rake_serial_number FROM train_session WHERE train_id = $1 OR rake_serial_number = $1 LIMIT 1",
      [trainId]
    );
    const actualTrainId = trainSessionRes.rows[0]?.train_id || trainId;
    const actualRakeSerialNumber = trainSessionRes.rows[0]?.rake_serial_number || null;

    // Get activity timeline from activity_timeline table
    // ✅ FIX: Use both train_id and rake_serial_number for queries
    let query, params;
    if (indentNumber) {
      query = `
        SELECT 
          id,
          activity_type,
          username,
          activity_time,
          notes
        FROM activity_timeline
        WHERE (train_id = $1 OR rake_serial_number = $1) AND (indent_number = $2 OR indent_number IS NULL)
        ORDER BY activity_time DESC
        LIMIT 50
      `;
      params = [actualTrainId, indentNumber];
    } else {
      query = `
        SELECT 
          id,
          activity_type,
          username,
          activity_time,
          notes
        FROM activity_timeline
        WHERE (train_id = $1 OR rake_serial_number = $1) AND (indent_number IS NULL OR indent_number = '')
        ORDER BY activity_time DESC
        LIMIT 50
      `;
      params = [actualTrainId];
    }

    const result = await pool.query(query, params);

    // Format activity timeline entries and group by date
    const activitiesByDate = {};

    result.rows.forEach(row => {
      const timestamp = row.activity_time;
      if (!timestamp) return;

      const date = new Date(timestamp);

      // Format date as "Today", "Yesterday", or actual date
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const activityDate = new Date(date);
      activityDate.setHours(0, 0, 0, 0);

      let dateLabel = "";
      if (activityDate.getTime() === today.getTime()) {
        dateLabel = "Today";
      } else {
        const yesterday = new Date(today);
        yesterday.setDate(yesterday.getDate() - 1);
        if (activityDate.getTime() === yesterday.getTime()) {
          dateLabel = "Yesterday";
        } else {
          dateLabel = date.toLocaleDateString('en-US', {
            year: 'numeric',
            month: 'short',
            day: 'numeric'
          });
        }
      }

      // Format time
      const timeLabel = date.toLocaleTimeString('en-US', {
        hour: '2-digit',
        minute: '2-digit',
        hour12: false
      });

      // Generate activity text based on activity type
      let activityText = "";
      switch (row.activity_type) {
        case 'SUBMITTED':
          activityText = `Entry has been submitted by ${row.username} at ${timeLabel}.`;
          break;
        case 'REVOKED':
          activityText = `Entry has been revoked by ${row.username} at ${timeLabel}.`;
          break;
        case 'REVOKED_BY_SUPER_ADMIN':
          activityText = `Entry has been revoked by SUPER_ADMIN ${row.username} at ${timeLabel}.`;
          break;
        case 'APPROVED':
          activityText = `Entry has been approved by ${row.username} at ${timeLabel}.`;
          break;
        case 'REJECTED':
          activityText = `Entry has been rejected by ${row.username} at ${timeLabel}.`;
          break;
        case 'CANCELLED':
          activityText = `Indent has been cancelled by ${row.username} at ${timeLabel}.`;
          break;
        case 'REVIEWER_SUBMITTED':
          // If we have custom notes (e.g. "Dispatch reviewed and approved by reviewer"),
          // append reviewer name and time to keep a consistent format.
          if (row.notes) {
            activityText = `${row.notes} by ${row.username} at ${timeLabel}.`;
          } else {
            activityText = `Dispatch has been submitted by ${row.username} at ${timeLabel}.`;
          }
          break;
        case 'REVIEWER_EDITED':
          activityText = row.notes || `Dispatch edited by ${row.username} at ${timeLabel}.`;
          break;
        case 'REVIEWER_SAVED':
          activityText = row.notes || `Dispatch saved by ${row.username} at ${timeLabel} (no changes).`;
          break;
        case 'REVIEWER_TRAIN_EDITED':
          // Parse notes to extract change details if present
          let changeDetails = null;
          let displayNotes = row.notes;
          if (row.notes && row.notes.includes('|||CHANGE_DETAILS:')) {
            const parts = row.notes.split('|||CHANGE_DETAILS:');
            displayNotes = parts[0]; // Human-readable notes
            try {
              changeDetails = JSON.parse(parts[1]);
            } catch (e) {
              console.error('Error parsing change details:', e);
            }
          }
          activityText = displayNotes || `Train data edited by ${row.username} at ${timeLabel}.`;
          break;
        case 'REVIEWER_TRAIN_SAVED':
          activityText = row.notes || `Train data saved by ${row.username} at ${timeLabel} (no changes).`;
          break;
        default:
          activityText = row.notes || `${row.activity_type} by ${row.username} at ${timeLabel}.`;
      }

      // Group by date
      if (!activitiesByDate[dateLabel]) {
        activitiesByDate[dateLabel] = [];
      }

      // Extract change details for REVIEWER_TRAIN_EDITED
      let changeDetails = null;
      if (row.activity_type === 'REVIEWER_TRAIN_EDITED' && row.notes && row.notes.includes('|||CHANGE_DETAILS:')) {
        const parts = row.notes.split('|||CHANGE_DETAILS:');
        try {
          changeDetails = JSON.parse(parts[1]);
        } catch (e) {
          console.error('Error parsing change details:', e);
        }
      }

      activitiesByDate[dateLabel].push({
        id: row.id, // Include activity ID for export
        time: timeLabel,
        text: activityText,
        timestamp: timestamp,
        username: row.username,
        activity_type: row.activity_type,
        notes: row.notes,
        changeDetails: changeDetails, // Include parsed change details
      });
    });

    // Convert to array format: [{ date, activities: [...] }]
    const groupedActivities = Object.keys(activitiesByDate).map(dateLabel => ({
      date: dateLabel,
      activities: activitiesByDate[dateLabel]
    }));

    res.json({ activities: groupedActivities });
  } catch (err) {
    console.error("ACTIVITY TIMELINE ERROR:", err);
    res.status(500).json({ message: "Failed to load activity timeline" });
  }
});

/* =====================================================
   EXPORT REVIEWER CHANGES TO EXCEL
   ===================================================== */
app.get("/train/:trainId/activity-timeline/:activityId/export-changes", allowRoles(["ADMIN", "REVIEWER", "SUPER_ADMIN"]), async (req, res) => {
  const { trainId, activityId } = req.params;

  try {
    // Get activity timeline entry
    const activityRes = await pool.query(
      `SELECT activity_type, notes, activity_time, username
       FROM activity_timeline
       WHERE id = $1 AND train_id = $2`,
      [activityId, trainId]
    );

    if (activityRes.rows.length === 0) {
      return res.status(404).json({ message: "Activity not found" });
    }

    const activity = activityRes.rows[0];
    
    // Parse change details from notes
    let changeDetails = null;
    if (activity.notes && activity.notes.includes('|||CHANGE_DETAILS:')) {
      const parts = activity.notes.split('|||CHANGE_DETAILS:');
      try {
        changeDetails = JSON.parse(parts[1]);
      } catch (e) {
        console.error('Error parsing change details:', e);
        return res.status(500).json({ message: "Failed to parse change details" });
      }
    } else {
      return res.status(400).json({ message: "No change details found for this activity" });
    }

    // Prepare Excel data: Location, Previous value, Modified value
    const excelData = [];
    
    // Add header row
    excelData.push(['Location', 'Previous value', 'Modified value']);

    // Add header changes
    if (changeDetails.headerChanges && changeDetails.headerChanges.length > 0) {
      changeDetails.headerChanges.forEach(change => {
        excelData.push([
          `Header: ${change.field}`,
          change.oldValue || '(empty)',
          change.newValue || '(empty)'
        ]);
      });
    }

    // Add wagon changes
    if (changeDetails.wagonChanges && changeDetails.wagonChanges.length > 0) {
      changeDetails.wagonChanges.forEach(change => {
        excelData.push([
          `${change.wagon}: ${change.field}`,
          change.oldValue || '(empty)',
          change.newValue || '(empty)'
        ]);
      });
    }

    // Create workbook and worksheet
    const worksheet = XLSX.utils.aoa_to_sheet(excelData);
    const workbook = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(workbook, worksheet, 'Reviewer Changes');

    // Set column widths
    worksheet['!cols'] = [
      { wch: 40 }, // Location
      { wch: 30 }, // Previous value
      { wch: 30 }  // Modified value
    ];

    // Generate filename with timestamp
    const timestamp = new Date(activity.activity_time).toISOString().replace(/[:.]/g, '-').slice(0, -5);
    const filename = `Reviewer_Changes_${trainId}_${timestamp}.xlsx`;

    // Generate buffer
    const excelBuffer = XLSX.write(workbook, { type: 'buffer', bookType: 'xlsx' });

    // Set response headers
    res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
    res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);

    // Send Excel file
    res.send(excelBuffer);
  } catch (err) {
    console.error("EXPORT CHANGES ERROR:", err);
    res.status(500).json({ message: "Failed to export changes" });
  }
});

/* =====================================================
   CHECK IF MULTIPLE RAKE SERIAL NUMBERS EXIST
   ===================================================== */
app.get(
  "/train/:trainId/check-multiple-serials",
  allowRoles(["ADMIN", "SUPER_ADMIN"]),
  async (req, res) => {
    const { trainId } = req.params;

    try {
      // Check if any train_session or dashboard_records exist with pattern trainId-N
      const sequentialSerials = await pool.query(
        `
        SELECT train_id FROM train_session 
        WHERE train_id LIKE $1 AND train_id != $2
        LIMIT 1
        `,
        [`${trainId}-%`, trainId]
      );

      const hasSequentialSerials = sequentialSerials.rows.length > 0;

      res.json({
        hasSequentialSerials,
        message: hasSequentialSerials
          ? "Sequential serial numbers already exist"
          : "No sequential serial numbers found",
      });
    } catch (err) {
      console.error("CHECK MULTIPLE SERIALS ERROR:", err);
      res.status(500).json({
        message: "Failed to check serial numbers",
        hasSequentialSerials: false,
      });
    }
  }
);

/* =====================================================
   GENERATE MULTIPLE RAKE SERIAL NUMBERS
   ===================================================== */
app.post(
  "/train/:trainId/generate-multiple-rake-serial",
  allowRoles(["ADMIN", "SUPER_ADMIN"]),
  async (req, res) => {
    const { trainId } = req.params;
    // trainId may be URL encoded (e.g., "2025-26%2F01%2F001"), decode it
    const decodedTrainId = decodeURIComponent(trainId);
    const { indentNumbers: indentNumbersFromBody } = req.body;

    try {
      // Get original train data - check both train_id and rake_serial_number
      const originalTrain = await pool.query(
        "SELECT * FROM train_session WHERE train_id = $1 OR rake_serial_number = $1",
        [decodedTrainId]
      );

      if (originalTrain.rows.length === 0) {
        return res.status(404).json({ message: "Original train not found" });
      }

      const originalData = originalTrain.rows[0];
      const actualTrainId = originalData.train_id; // Use actual train_id from train_session
      const siding = originalData.siding;

      // Get existing dashboard_records to get all indent numbers
      // Check both train_id and rake_serial_number, and also check for sequential patterns
      const existingDashboardRecords = await pool.query(
        "SELECT * FROM dashboard_records WHERE (train_id = $1 OR rake_serial_number = $1) OR train_id LIKE $2",
        [decodedTrainId, `${actualTrainId}-%`]
      );

      if (existingDashboardRecords.rows.length === 0) {
        return res.status(404).json({ message: "No dashboard records found for this train" });
      }

      // Check if serial numbers have already been generated (if any record has train_id like 2024-25/01/001-1, 2024-25/01/001-2, etc.)
      const hasSequentialSerials = existingDashboardRecords.rows.some(
        r => r.train_id.includes(`${actualTrainId}-`) && r.train_id !== actualTrainId
      );

      if (hasSequentialSerials) {
        return res.status(400).json({
          message: "Multiple rake serial numbers have already been generated for this train"
        });
      }

      // Filter to only records with the original train_id (use actualTrainId from train_session)
      // Also check rake_serial_number in case records were matched by rake_serial_number
      const originalRecords = existingDashboardRecords.rows.filter(r =>
        r.train_id === actualTrainId || r.rake_serial_number === decodedTrainId
      );

      if (originalRecords.length === 0) {
        return res.status(404).json({ message: "No dashboard records found with original train_id" });
      }

      // Get distinct indent numbers - prefer from request body if provided, otherwise from database records
      let indentNumbers = [];
      if (indentNumbersFromBody && Array.isArray(indentNumbersFromBody) && indentNumbersFromBody.length > 0) {
        // Use indent numbers from request body (from frontend)
        indentNumbers = indentNumbersFromBody
          .filter(Boolean)
          .filter((v, i, a) => a.indexOf(v) === i); // unique
      } else {
        // Fallback to getting indent numbers from database records
        indentNumbers = originalRecords
          .map(r => r.indent_number)
          .filter(Boolean)
          .filter((v, i, a) => a.indexOf(v) === i); // unique
      }

      if (indentNumbers.length === 0) {
        return res.status(400).json({ message: "No indent numbers found. Please provide indent numbers in the request body or ensure they exist in dashboard records." });
      }

      // Instead of generating sequential numbers immediately, just set a flag
      // Sequential numbers will be assigned when bag counting starts (loaded_bag_count > 0)
      // Update all dashboard records to set pending_sequential_serials flag
      // Use actualTrainId from train_session
      await pool.query(
        `
        UPDATE dashboard_records
        SET has_sequential_serials = TRUE,
            single_indent = FALSE
        WHERE train_id = $1
        `,
        [actualTrainId]
      );

      // Delete the parent record (with null/empty indent_number) immediately when splitting
      await pool.query(
        "DELETE FROM dashboard_records WHERE train_id = $1 AND (indent_number IS NULL OR indent_number = '')",
        [actualTrainId]
      );
      console.log(`[GENERATE MULTIPLE RAKE SERIAL] Deleted parent record for ${actualTrainId} when splitting into indents`);

      res.json({
        message: "Multiple rake serial numbers will be assigned when bag counting starts for each indent",
        pending: true,
      });
    } catch (err) {
      console.error("GENERATE MULTIPLE RAKE SERIAL ERROR:", err);
      res.status(500).json({ message: `Failed to generate serial numbers: ${err.message}` });
    }
  }
);

// Mark that multiple rake serial question has been answered (when "No" was selected)
app.post(
  "/train/:trainId/mark-serial-handled",
  allowRoles(["ADMIN", "REVIEWER", "SUPER_ADMIN"]),
  async (req, res) => {
    const { trainId } = req.params;
    // trainId may be URL encoded (e.g., "2025-26%2F01%2F001"), decode it
    const decodedTrainId = decodeURIComponent(trainId);

    try {
      // First, find the actual train_id from dashboard_records
      // Check both train_id and rake_serial_number
      const dashboardCheck = await pool.query(
        "SELECT train_id FROM dashboard_records WHERE train_id = $1 OR rake_serial_number = $1 LIMIT 1",
        [decodedTrainId]
      );

      let actualTrainId = decodedTrainId;
      if (dashboardCheck.rows.length > 0) {
        actualTrainId = dashboardCheck.rows[0].train_id;
      } else {
        // Fallback to train_session
        const trainSessionCheck = await pool.query(
          "SELECT train_id FROM train_session WHERE train_id = $1 OR rake_serial_number = $1 LIMIT 1",
          [decodedTrainId]
        );
        if (trainSessionCheck.rows.length > 0) {
          actualTrainId = trainSessionCheck.rows[0].train_id;
        }
      }

      // ✅ FIX: When "No" is selected, set has_sequential_serials = FALSE
      // This prevents sequential train IDs from being assigned
      // Use actualTrainId for the update
      const result = await pool.query(
        `
        UPDATE dashboard_records
        SET has_sequential_serials = FALSE
        WHERE train_id = $1
        `,
        [actualTrainId]
      );

      // ✅ FIX: Explicitly delete any parent/single-indent records that might have persisted
      await pool.query(
        "DELETE FROM dashboard_records WHERE train_id = $1 AND (indent_number IS NULL OR indent_number = '' OR single_indent = true)",
        [actualTrainId]
      );

      if (result.rowCount === 0) {
        return res.status(404).json({ message: "Train not found" });
      }

      res.json({ message: "Serial handling marked successfully (sequential numbers disabled)" });
    } catch (err) {
      console.error("MARK SERIAL HANDLED ERROR:", err);
      res.status(500).json({ message: "Failed to mark serial handling" });
    }
  }
);

/* =====================================================
   CAMERA LIST BY SPUR (BASED ON ACTUAL TABLE)
===================================================== */
app.get("/cameras", async (req, res) => {
  const { siding, search = "", status } = req.query;

  if (!siding) {
    return res.status(400).json({ message: "siding is required" });
  }

  try {
    const conditions = ["siding = $1"];
    const values = [siding];
    let idx = 2;

    if (search) {
      conditions.push(`LOWER(camera_name) LIKE $${idx}`);
      values.push(`%${search.toLowerCase()}%`);
      idx++;
    }

    if (status === "active") {
      conditions.push(`status = true`);
    }

    if (status === "inactive") {
      conditions.push(`status = false`);
    }

    const query = `
      SELECT
        id,
        camera_name,
        siding,
        status
      FROM camera_records
      WHERE ${conditions.join(" AND ")}
      ORDER BY camera_name
    `;

    const result = await pool.query(query, values);
    res.json(result.rows);
  } catch (err) {
    console.error("CAMERA LIST ERROR:", err);
    res.status(500).json({ message: "Failed to load cameras" });
  }
});

app.get(
  "/random-counting/trains",
  allowRoles(["REVIEWER"]),
  async (req, res) => {
    try {
      const result = await pool.query(`
        SELECT train_id
        FROM dashboard_records
        WHERE status != 'APPROVED'
        ORDER BY created_time DESC
      `);

      res.json(result.rows);
    } catch (err) {
      console.error("RANDOM TRAIN LOAD ERROR:", err);
      res.status(500).json({ message: "Failed to load trains" });
    }
  }
);

app.get(
  "/random-counting/wagons/:trainId",
  allowRoles(["REVIEWER"]),
  async (req, res) => {
    const { trainId } = req.params;

    try {
      const result = await pool.query(
        `
        SELECT
          wagon_number,
          tower_number,
          loaded_bag_count,
          unloaded_bag_count
        FROM wagon_records
        WHERE train_id = $1
        ORDER BY tower_number
        `,
        [trainId]
      );

      res.json(result.rows);
    } catch (err) {
      console.error("RANDOM WAGON LOAD ERROR:", err);
      res.status(500).json({ message: "Failed to load wagons" });
    }
  }
);

app.get(
  "/random-counting/live-count",
  allowRoles(["REVIEWER"]),
  async (req, res) => {
    const { train_id, wagon_number } = req.query;

    if (!train_id || !wagon_number) {
      return res.status(400).json({ message: "Missing parameters" });
    }

    try {
      const result = await pool.query(
        `
        SELECT
          loaded_bag_count,
          unloaded_bag_count
        FROM wagon_records
        WHERE train_id = $1 AND wagon_number = $2
        `,
        [train_id, wagon_number]
      );

      if (!result.rows.length) {
        return res.status(404).json({ message: "Wagon not found" });
      }

      res.json(result.rows[0]);
    } catch (err) {
      console.error("RANDOM LIVE COUNT ERROR:", err);
      res.status(500).json({ message: "Live count failed" });
    }
  }
);

app.post(
  "/random-counting/start",
  allowRoles(["REVIEWER"]),
  async (req, res) => {
    const {
      train_id,
      wagon_number,
      tower_number,
      start_loaded_count,
      start_unloaded_count,
    } = req.body;

    try {
      await pool.query(
        `
        INSERT INTO random_counting_records (
          train_id,
          wagon_number,
          tower_number,
          start_loaded_count,
          start_unloaded_count,
          inspected_loading_count,
          inspected_unloading_count,
          random_count_start_time,
          status
        )
        VALUES ($1, $2, $3, $4, $5, 0, 0, NOW(), 'IN_PROGRESS')
        `,
        [
          train_id,
          wagon_number,
          tower_number,
          start_loaded_count,
          start_unloaded_count,
        ]
      );

      res.json({ message: "Random counting inspection started" });
    } catch (err) {
      console.error("RANDOM START ERROR:", err);
      res.status(500).json({ message: "Failed to start inspection" });
    }
  }
);
// ===============================
// GET COMPLETED RANDOM COUNTINGS
// ===============================
app.get(
  "/random-counting/completed",
  allowRoles(["REVIEWER", "ADMIN"]),
  async (req, res) => {
    try {
      const result = await pool.query(`
        SELECT
          id,
          train_id,
          wagon_number,
          tower_number,
          inspected_loading_count,
          inspected_unloading_count,
          random_count_start_time,
          random_count_end_time,
          client_surveyor_name,
          bothra_surveyor_name,
          client_representative_name,
          remarks
        FROM random_counting_records
        WHERE status = 'COMPLETED'
        ORDER BY random_count_end_time DESC
      `);

      res.json(result.rows);
    } catch (err) {
      console.error("RANDOM COMPLETED LIST ERROR:", err);
      res.status(500).json({ message: "Failed to load completed inspections" });
    }
  }
);

// =====================================
// GET SINGLE COMPLETED RANDOM COUNTING
// =====================================
app.get(
  "/random-counting/completed/:id",
  allowRoles(["REVIEWER", "ADMIN"]),
  async (req, res) => {
    const { id } = req.params;

    try {
      const result = await pool.query(
        `
        SELECT
          id,
          train_id,
          wagon_number,
          tower_number,
          start_loaded_count,
          start_unloaded_count,
          inspected_loading_count,
          inspected_unloading_count,
          random_count_start_time,
          random_count_end_time,
          inspection_start_time,
          inspection_end_time,
          client_surveyor_name,
          bothra_surveyor_name,
          client_representative_name,
          remarks,
          created_at
        FROM random_counting_records
        WHERE id = $1
          AND status = 'COMPLETED'
        `,
        [id]
      );

      if (!result.rows.length) {
        return res.status(404).json({ message: "Record not found" });
      }

      res.json(result.rows[0]);
    } catch (err) {
      console.error("RANDOM COMPLETED VIEW ERROR:", err);
      res.status(500).json({ message: "Failed to load inspection details" });
    }
  }
);



// ===============================
// COMPLETE RANDOM INSPECTION
// ===============================
app.post(
  "/random-counting/complete",
  allowRoles(["REVIEWER"]),
  async (req, res) => {
    const {
      train_id,
      wagon_number,
      inspected_loading_count,
      inspected_unloading_count,
    } = req.body;

    try {
      await pool.query(
        `
        UPDATE random_counting_records
        SET
          inspected_loading_count = $1,
          inspected_unloading_count = $2,
          inspection_end_time = NOW(),
          random_count_end_time = NOW(),
          status = 'COMPLETED'
        WHERE train_id = $3
          AND wagon_number = $4
          AND status = 'IN_PROGRESS'
        `,
        [
          inspected_loading_count,
          inspected_unloading_count,
          train_id,
          wagon_number,
        ]
      );

      res.json({ message: "Inspection completed successfully" });
    } catch (err) {
      console.error("RANDOM COMPLETE ERROR:", err);
      res.status(500).json({ message: "Failed to complete inspection" });
    }
  }
);





// ===============================
// SAVE RANDOM COUNTING DETAILS
// ===============================
app.post(
  "/random-counting/save",
  allowRoles(["REVIEWER"]),
  async (req, res) => {
    const {
      train_id,
      wagon_number,
      client_surveyor_name,
      bothra_surveyor_name,
      client_representative_name,
      remarks,
    } = req.body;

    try {
      await pool.query(
        `
        UPDATE random_counting_records
        SET
          client_surveyor_name = $1,
          bothra_surveyor_name = $2,
          client_representative_name = $3,
          remarks = $4
        WHERE train_id = $5
          AND wagon_number = $6
          AND status = 'COMPLETED'
        `,
        [
          client_surveyor_name,
          bothra_surveyor_name,
          client_representative_name,
          remarks,
          train_id,
          wagon_number,
        ]
      );

      res.json({ message: "Random counting saved" });
    } catch (err) {
      console.error("RANDOM SAVE ERROR:", err);
      res.status(500).json({ message: "Failed to save details" });
    }
  }
);


app.put("/wagon/:trainId/:towerNumber/status", async (req, res) => {
  const { trainId, towerNumber } = req.params;
  const { loading_status } = req.body;

  try {
    await pool.query(
      `
      UPDATE wagon_records
      SET loading_status = $1
      WHERE (train_id = $2 OR rake_serial_number = $2) AND tower_number = $3
      `,
      [loading_status, trainId, towerNumber]
    );

    res.json({ message: "Wagon status updated" });
  } catch (err) {
    console.error("WAGON STATUS UPDATE ERROR:", err);
    res.status(500).json({ message: "Failed to update wagon status" });
  }
});

/* =====================================================
   REVIEWER TASK MANAGEMENT
===================================================== */

// Get tasks for reviewer based on tab
app.get("/reviewer/tasks", allowRoles(["REVIEWER"]), async (req, res) => {
  const { tab } = req.query; // open, assigned, completed
  const reviewerUsername = req.headers["x-reviewer-username"];

  try {
    let query, params;

    if (tab === "open") {
      // Open tasks: PENDING_APPROVAL status, not assigned to anyone
      query = `
        SELECT 
          d.train_id,
          d.indent_number,
          d.siding,
          d.status,
          d.created_time,
          dp.rake_loading_start_datetime,
          dp.rake_loading_end_actual,
          COALESCE(SUM(w.loaded_bag_count), 0) AS total_bags_loaded
        FROM dashboard_records d
        LEFT JOIN dispatch_records dp ON (dp.train_id = d.train_id OR dp.rake_serial_number = d.rake_serial_number)
          AND (
            d.single_indent = true 
            OR dp.indent_number = d.indent_number 
            OR (dp.indent_number IS NULL AND (d.indent_number IS NULL OR d.indent_number = ''))
          )
        LEFT JOIN wagon_records w ON w.rake_serial_number = d.rake_serial_number
          AND (d.single_indent = true OR w.indent_number = d.indent_number)
        WHERE d.status = 'PENDING_APPROVAL' 
          AND (d.assigned_reviewer IS NULL OR d.assigned_reviewer = '')
        GROUP BY d.train_id, d.indent_number, d.siding, d.status, d.created_time,
          dp.rake_loading_start_datetime, dp.rake_loading_end_actual
        ORDER BY d.created_time DESC
`;
      params = [];
    } else if (tab === "assigned") {
      // Assigned tasks: assigned to this reviewer (can be PENDING_APPROVAL or LOADING_IN_PROGRESS)
      query = `
        SELECT 
          d.train_id,
          d.indent_number,
          d.siding,
          d.status,
          d.created_time,
          dp.rake_loading_start_datetime,
          dp.rake_loading_end_actual,
          COALESCE(SUM(w.loaded_bag_count), 0) AS total_bags_loaded
        FROM dashboard_records d
        LEFT JOIN dispatch_records dp ON (dp.train_id = d.train_id OR dp.rake_serial_number = d.rake_serial_number)
          AND (
            d.single_indent = true 
            OR dp.indent_number = d.indent_number 
            OR (dp.indent_number IS NULL AND (d.indent_number IS NULL OR d.indent_number = ''))
          )
        LEFT JOIN wagon_records w ON w.rake_serial_number = d.rake_serial_number
          AND (d.single_indent = true OR w.indent_number = d.indent_number)
        WHERE d.assigned_reviewer = $1
          AND d.status IN ('PENDING_APPROVAL', 'LOADING_IN_PROGRESS')
        GROUP BY d.train_id, d.indent_number, d.siding, d.status, d.created_time,
          dp.rake_loading_start_datetime, dp.rake_loading_end_actual
        ORDER BY d.created_time DESC
      `;
      params = [reviewerUsername];
    } else if (tab === "completed") {
      // Completed tasks: APPROVED status, assigned to this reviewer
      query = `
        SELECT 
          d.train_id,
          d.indent_number,
          d.siding,
          d.status,
          d.created_time,
          dp.rake_loading_start_datetime,
          dp.rake_loading_end_actual,
          COALESCE(SUM(w.loaded_bag_count), 0) AS total_bags_loaded
        FROM dashboard_records d
        LEFT JOIN dispatch_records dp ON (dp.train_id = d.train_id OR dp.rake_serial_number = d.rake_serial_number)
          AND (
            d.single_indent = true 
            OR dp.indent_number = d.indent_number 
            OR (dp.indent_number IS NULL AND (d.indent_number IS NULL OR d.indent_number = ''))
          )
        LEFT JOIN wagon_records w ON w.rake_serial_number = d.rake_serial_number
          AND (d.single_indent = true OR w.indent_number = d.indent_number)
        WHERE d.status = 'APPROVED' 
          AND d.assigned_reviewer = $1
        GROUP BY d.train_id, d.indent_number, d.siding, d.status, d.created_time,
          dp.rake_loading_start_datetime, dp.rake_loading_end_actual
        ORDER BY d.created_time DESC
      `;
      params = [reviewerUsername];
    } else {
      return res.status(400).json({ message: "Invalid tab parameter" });
    }

    const result = await pool.query(query, params);
    res.json({ tasks: result.rows });
  } catch (err) {
    console.error("REVIEWER TASKS ERROR:", err);
    res.status(500).json({ message: "Failed to fetch tasks" });
  }
});

// Assign task to reviewer
app.post("/reviewer/tasks/:trainId/assign", allowRoles(["REVIEWER"]), async (req, res) => {
  const { trainId } = req.params;
  // ✅ FIX: Normalize indent_number (treat null, undefined, and empty string consistently)
  const rawIndentNumber = req.body && req.body.indent_number;
  const indent_number = rawIndentNumber && rawIndentNumber.trim() !== "" ? rawIndentNumber.trim() : null;
  const reviewerUsername = req.headers["x-reviewer-username"];

  try {
    // ✅ FIX: Resolve actual train_id first (URL trainId might be rake_serial_number)
    const trainSessionRes = await pool.query(
      "SELECT train_id FROM train_session WHERE train_id = $1 OR rake_serial_number = $1 LIMIT 1",
      [trainId]
    );
    const actualTrainId = trainSessionRes.rows[0]?.train_id || trainId;

    // Update dashboard_records to assign to this reviewer and set status to LOADING_IN_PROGRESS
    // ✅ FIX: Check both train_id and rake_serial_number columns
    let updateQuery, updateParams;

    if (indent_number) {
      updateQuery = `
        UPDATE dashboard_records 
        SET assigned_reviewer = $1,
            status = 'LOADING_IN_PROGRESS'
        WHERE (train_id = $2 OR rake_serial_number = $2) AND indent_number = $3
      `;
      updateParams = [reviewerUsername, actualTrainId, indent_number];
    } else {
      updateQuery = `
        UPDATE dashboard_records 
        SET assigned_reviewer = $1,
            status = 'LOADING_IN_PROGRESS'
        WHERE (train_id = $2 OR rake_serial_number = $2)
        AND (indent_number IS NULL OR indent_number = '')
      `;
      updateParams = [reviewerUsername, actualTrainId];
    }

    const result = await pool.query(updateQuery, updateParams);

    if (result.rowCount === 0) {
      return res.status(404).json({ message: "Task not found" });
    }

    res.json({ message: "Task assigned successfully" });
  } catch (err) {
    console.error("ASSIGN TASK ERROR:", err);
    res.status(500).json({ message: "Failed to assign task" });
  }
});

// Approve task (complete review)
app.post("/reviewer/tasks/:trainId/approve", allowRoles(["REVIEWER"]), async (req, res) => {
  const { trainId } = req.params;
  const { indent_number } = req.body;
  const reviewerUsername = req.headers["x-reviewer-username"];

  try {
    // ✅ FIX: Resolve actual train_id first (URL trainId might be rake_serial_number)
    // Also check dashboard_records in case train_session doesn't have the record
    const trainSessionRes = await pool.query(
      "SELECT train_id, rake_serial_number FROM train_session WHERE train_id = $1 OR rake_serial_number = $1 LIMIT 1",
      [trainId]
    );
    let actualTrainId = trainSessionRes.rows[0]?.train_id || trainId;
    let actualRakeSerialNumber = trainSessionRes.rows[0]?.rake_serial_number || null;
    
    // If not found in train_session, check dashboard_records
    if (!trainSessionRes.rows.length) {
      const dashboardCheck = await pool.query(
        "SELECT train_id, rake_serial_number FROM dashboard_records WHERE train_id = $1 OR rake_serial_number = $1 LIMIT 1",
        [trainId]
      );
      if (dashboardCheck.rows.length > 0) {
        actualTrainId = dashboardCheck.rows[0].train_id || trainId;
        actualRakeSerialNumber = dashboardCheck.rows[0].rake_serial_number || null;
      }
    }

    // ✅ FIX: Normalize indent_number (treat null, undefined, and empty string consistently)
    const indentNum = indent_number && indent_number.trim() !== "" ? indent_number.trim() : null;

    // ✅ FIX: Get current dispatch record to track final changes before approval
    // Use both train_id and rake_serial_number for queries
    let dispatchQuery, dispatchParams;
    if (indentNum) {
      dispatchQuery = `
        SELECT indent_wagon_count, vessel_name, rake_type, rake_placement_datetime,
               rake_clearance_datetime, rake_idle_time, loading_start_officer,
               loading_completion_officer, remarks, rr_number, rake_loading_end_railway,
               rake_loading_start_datetime, rake_loading_end_actual, status
        FROM dispatch_records
        WHERE (train_id = $1 OR rake_serial_number = $1) AND indent_number = $2
      `;
      dispatchParams = [actualTrainId, indentNum];
    } else {
      dispatchQuery = `
        SELECT indent_wagon_count, vessel_name, rake_type, rake_placement_datetime,
               rake_clearance_datetime, rake_idle_time, loading_start_officer,
               loading_completion_officer, remarks, rr_number, rake_loading_end_railway,
               rake_loading_start_datetime, rake_loading_end_actual, status
        FROM dispatch_records
        WHERE (train_id = $1 OR rake_serial_number = $1) AND (indent_number IS NULL OR indent_number = '')
      `;
      dispatchParams = [actualTrainId];
    }

    const dispatchRes = await pool.query(dispatchQuery, dispatchParams);
    const dispatchRecord = dispatchRes.rows[0];

    // ✅ FIX: Update status to APPROVED - check both train_id and rake_serial_number
    // Also check original trainId (URL parameter) in case it's a rake_serial_number that doesn't match train_id
    let updateQuery, updateParams;

    if (indentNum) {
      updateQuery = `
        UPDATE dashboard_records 
        SET status = 'APPROVED'
        WHERE ((train_id = $1 OR rake_serial_number = $1) OR (train_id = $4 OR rake_serial_number = $4))
          AND indent_number = $2 
          AND assigned_reviewer = $3
      `;
      updateParams = [actualTrainId, indentNum, reviewerUsername, trainId]; // Check both actualTrainId and original trainId
    } else {
      updateQuery = `
        UPDATE dashboard_records 
        SET status = 'APPROVED'
        WHERE ((train_id = $1 OR rake_serial_number = $1) OR (train_id = $3 OR rake_serial_number = $3))
          AND assigned_reviewer = $2
          AND (indent_number IS NULL OR indent_number = '')
      `;
      updateParams = [actualTrainId, reviewerUsername, trainId]; // Check both actualTrainId and original trainId
    }

    const result = await pool.query(updateQuery, updateParams);

    if (result.rowCount === 0) {
      // ✅ FIX: Better error message with debugging info
      console.error(`[APPROVE TASK] No matching record found:`, {
        trainId,
        indent_number: indentNum,
        reviewerUsername,
        query: updateQuery,
        params: updateParams
      });

      // Check if task exists but assigned to different reviewer - check both train_id and rake_serial_number
      // Also check original trainId (URL parameter) in case it's a rake_serial_number
      let checkQuery, checkParams;
      if (indentNum) {
        checkQuery = `SELECT train_id, rake_serial_number, assigned_reviewer FROM dashboard_records 
                      WHERE ((train_id = $1 OR rake_serial_number = $1) OR (train_id = $3 OR rake_serial_number = $3)) 
                      AND indent_number = $2`;
        checkParams = [actualTrainId, indentNum, trainId]; // Check both actualTrainId and original trainId
      } else {
        checkQuery = `SELECT train_id, rake_serial_number, assigned_reviewer FROM dashboard_records 
                      WHERE ((train_id = $1 OR rake_serial_number = $1) OR (train_id = $2 OR rake_serial_number = $2))
                      AND (indent_number IS NULL OR indent_number = '')`;
        checkParams = [actualTrainId, trainId]; // Check both actualTrainId and original trainId
      }

      const checkResult = await pool.query(checkQuery, checkParams);
      if (checkResult.rows.length > 0) {
        const assignedTo = checkResult.rows[0].assigned_reviewer;
        const foundTrainId = checkResult.rows[0].train_id;
        const foundRakeSerial = checkResult.rows[0].rake_serial_number;
        
        console.error(`[APPROVE TASK] Record found but assigned_reviewer mismatch:`, {
          foundTrainId,
          foundRakeSerial,
          assignedTo,
          expectedReviewer: reviewerUsername,
          urlTrainId: trainId,
          actualTrainId,
          actualRakeSerialNumber
        });
        
        if (assignedTo && assignedTo !== reviewerUsername) {
          return res.status(403).json({
            message: `Task is assigned to a different reviewer: ${assignedTo}`
          });
        }
      } else {
        // Record doesn't exist at all - log more details
        console.error(`[APPROVE TASK] Record not found in dashboard_records:`, {
          searchedTrainId: actualTrainId,
          searchedRakeSerial: actualRakeSerialNumber,
          originalUrlTrainId: trainId,
          indentNumber: indentNum,
          reviewerUsername
        });
      }

      return res.status(404).json({
        message: "Task not found or not assigned to you. Please check the train ID and indent number."
      });
    }

    // ✅ FIX: Add activity timeline entry with reviewer submission details
    // Always record username and timestamp, even if no changes
    let activityNotes = 'Dispatch submitted and approved by reviewer';

    if (dispatchRecord && dispatchRecord.status === 'DRAFT') {
      // Record that reviewer reviewed and approved the dispatch
      activityNotes = 'Dispatch reviewed and approved by reviewer';
    } else if (dispatchRecord && dispatchRecord.status === 'PENDING_APPROVAL') {
      // Record approval of admin-submitted dispatch
      activityNotes = 'Dispatch approved by reviewer (no changes made)';
    }

    await addActivityTimelineEntry(
      actualTrainId,
      indentNum || null,
      'REVIEWER_SUBMITTED',
      reviewerUsername,
      activityNotes
    );

    res.json({ message: "Task approved successfully" });
  } catch (err) {
    console.error("APPROVE TASK ERROR:", err);
    res.status(500).json({ message: "Failed to approve task" });
  }
});

// Reject task
app.post("/reviewer/tasks/:trainId/reject", allowRoles(["REVIEWER"]), async (req, res) => {
  const { trainId } = req.params;
  const { indent_number } = req.body;
  const reviewerUsername = req.headers["x-reviewer-username"];

  try {
    // Update status to REJECTED and unassign
    let updateQuery, updateParams;

    if (indent_number) {
      updateQuery = `
        UPDATE dashboard_records 
        SET status = 'REJECTED',
            assigned_reviewer = NULL
        WHERE train_id = $1 AND indent_number = $2 AND assigned_reviewer = $3
      `;
      updateParams = [trainId, indent_number, reviewerUsername];
    } else {
      updateQuery = `
        UPDATE dashboard_records 
        SET status = 'REJECTED',
            assigned_reviewer = NULL
        WHERE train_id = $1 AND assigned_reviewer = $2
      `;
      updateParams = [trainId, reviewerUsername];
    }

    const result = await pool.query(updateQuery, updateParams);

    if (result.rowCount === 0) {
      return res.status(404).json({ message: "Task not found or not assigned to you" });
    }

    // Add activity timeline entry for rejection
    const { remarks } = req.body;
    await addActivityTimelineEntry(
      trainId,
      indent_number || null,
      'REJECTED',
      reviewerUsername,
      remarks ? `Task rejected: ${remarks}` : 'Task rejected by reviewer'
    );

    res.json({ message: "Task rejected successfully" });
  } catch (err) {
    console.error("REJECT TASK ERROR:", err);
    res.status(500).json({ message: "Failed to reject task" });
  }
});

// Cancel task (with remarks)
app.post("/reviewer/tasks/:trainId/cancel", allowRoles(["REVIEWER"]), async (req, res) => {
  const { trainId } = req.params;
  const { indent_number, remarks } = req.body;
  const reviewerUsername = req.headers["x-reviewer-username"];

  try {
    // ✅ FIX: Resolve actual train_id first (URL trainId might be rake_serial_number)
    const trainSessionRes = await pool.query(
      "SELECT train_id FROM train_session WHERE train_id = $1 OR rake_serial_number = $1 LIMIT 1",
      [trainId]
    );
    const actualTrainId = trainSessionRes.rows[0]?.train_id || trainId;

    // Update status to CANCELLED - check both train_id and rake_serial_number
    let updateQuery, updateParams;

    if (indent_number) {
      updateQuery = `
        UPDATE dashboard_records 
        SET status = 'CANCELLED',
            cancellation_remarks = $1,
            cancelled_by = $2,
            cancelled_at = NOW()
        WHERE (train_id = $3 OR rake_serial_number = $3) AND indent_number = $4 AND assigned_reviewer = $5
      `;
      updateParams = [remarks, reviewerUsername, actualTrainId, indent_number, reviewerUsername];
    } else {
      updateQuery = `
        UPDATE dashboard_records 
        SET status = 'CANCELLED',
            cancellation_remarks = $1,
            cancelled_by = $2,
            cancelled_at = NOW()
        WHERE (train_id = $3 OR rake_serial_number = $3) AND assigned_reviewer = $4
      `;
      updateParams = [remarks, reviewerUsername, actualTrainId, reviewerUsername];
    }

    const result = await pool.query(updateQuery, updateParams);

    if (result.rowCount === 0) {
      return res.status(404).json({ message: "Task not found or not assigned to you" });
    }

    // Add activity timeline entry for cancellation - use actualTrainId
    await addActivityTimelineEntry(
      actualTrainId,
      indent_number || null,
      'CANCELLED',
      reviewerUsername,
      remarks ? `Indent cancelled: ${remarks}` : 'Indent cancelled by reviewer'
    );

    res.json({ message: "Task cancelled successfully" });
  } catch (err) {
    console.error("CANCEL TASK ERROR:", err);
    res.status(500).json({ message: "Failed to cancel task" });
  }
});

// Get reviewer train data (for verify page)
app.get("/reviewer/train/:trainId", allowRoles(["REVIEWER"]), async (req, res) => {
  const { trainId } = req.params;
  const indentNumber = req.query.indent_number;

  try {
    // ✅ FIX: Resolve actual train_id first (URL trainId might be rake_serial_number)
    const trainSessionRes = await pool.query(
      "SELECT train_id FROM train_session WHERE train_id = $1 OR rake_serial_number = $1 LIMIT 1",
      [trainId]
    );
    const actualTrainId = trainSessionRes.rows[0]?.train_id || trainId;

    // Get header data - check both train_id and rake_serial_number
    let headerQuery, headerParams;
    if (indentNumber) {
      headerQuery = `
        SELECT d.*, c.customer_name
        FROM dashboard_records d
        LEFT JOIN customers c ON c.id = d.customer_id
        WHERE (d.train_id = $1 OR d.rake_serial_number = $1) AND d.indent_number = $2
        LIMIT 1
      `;
      headerParams = [actualTrainId, indentNumber];
    } else {
      headerQuery = `
        SELECT d.*, c.customer_name
        FROM dashboard_records d
        LEFT JOIN customers c ON c.id = d.customer_id
        WHERE (d.train_id = $1 OR d.rake_serial_number = $1)
        LIMIT 1
      `;
      headerParams = [actualTrainId];
    }

    const headerRes = await pool.query(headerQuery, headerParams);

    if (headerRes.rows.length === 0) {
      return res.status(404).json({ message: "Train not found" });
    }

    // Get wagon data - use actualTrainId
    let wagonQuery, wagonParams;
    if (indentNumber) {
      wagonQuery = `
        SELECT * FROM wagon_records
        WHERE (train_id = $1 OR rake_serial_number = $1) AND indent_number = $2
        ORDER BY tower_number
      `;
      wagonParams = [actualTrainId, indentNumber];
    } else {
      wagonQuery = `
        SELECT * FROM wagon_records
        WHERE (train_id = $1 OR rake_serial_number = $1)
        ORDER BY tower_number
      `;
      wagonParams = [actualTrainId];
    }

    const wagonRes = await pool.query(wagonQuery, wagonParams);

    // Get dispatch data - ✅ FIX: Use both train_id and rake_serial_number
    const dispatchRes = await pool.query(
      "SELECT * FROM dispatch_records WHERE (train_id = $1 OR rake_serial_number = $1)",
      [actualTrainId]
    );

    res.json({
      header: headerRes.rows[0],
      wagons: wagonRes.rows,
      dispatch: dispatchRes.rows[0] || null,
    });
  } catch (err) {
    console.error("REVIEWER LOAD ERROR:", err);
    res.status(500).json({ message: "Failed to load train data" });
  }
});

/* =====================================================
   REVOKE TRAIN
   - SUPER_ADMIN: can revoke APPROVED trains (back to LOADING_IN_PROGRESS)
   - ADMIN: can revoke PENDING_APPROVAL trains ONLY while unassigned
===================================================== */
app.post(
  "/train/:trainId/revoke",
  allowRoles(["SUPER_ADMIN", "ADMIN"]),
  async (req, res) => {
    const { trainId } = req.params;
    const { indent_number, username } = req.body;
    const role = req.headers["x-user-role"];

    try {
      // Check if train exists and is APPROVED
      let checkQuery, checkParams;
      if (indent_number) {
        checkQuery = `
          SELECT status, assigned_reviewer 
          FROM dashboard_records 
          WHERE train_id = $1 AND indent_number = $2
        `;
        checkParams = [trainId, indent_number];
      } else {
        checkQuery = `
          SELECT status, assigned_reviewer 
          FROM dashboard_records 
          WHERE train_id = $1
        `;
        checkParams = [trainId];
      }

      const checkRes = await pool.query(checkQuery, checkParams);

      if (checkRes.rows.length === 0) {
        return res.status(404).json({ message: "Train not found" });
      }

      const row = checkRes.rows[0];
      const status = row.status;
      const assignedReviewer = row.assigned_reviewer;

      if (role === "SUPER_ADMIN") {
        // SUPER_ADMIN can revoke only APPROVED trains
        if (status !== "APPROVED") {
          return res.status(400).json({
            message: "Only APPROVED trains can be revoked by SUPER_ADMIN",
          });
        }
      } else if (role === "ADMIN") {
        // ADMIN can revoke only PENDING_APPROVAL submissions that are not yet assigned
        if (status !== "PENDING_APPROVAL") {
          return res.status(400).json({
            message: "Only PENDING_APPROVAL submissions can be revoked by ADMIN",
          });
        }

        if (assignedReviewer && assignedReviewer !== "") {
          return res.status(400).json({
            message:
              "This task has already been assigned to a reviewer and can no longer be revoked",
          });
        }
      } else {
        // Should be unreachable because of allowRoles, but keep as safety
        return res.status(403).json({ message: "Not allowed to revoke" });
      }

      // Update status to LOADING_IN_PROGRESS
      // For SUPER_ADMIN: also clear assigned_reviewer so reviewer no longer has edit access
      // For ADMIN: keep assigned_reviewer intact (ADMIN can only revoke before assignment anyway)
      let updateQuery, updateParams;
      if (indent_number) {
        if (role === "SUPER_ADMIN") {
          updateQuery = `
            UPDATE dashboard_records 
            SET status = 'LOADING_IN_PROGRESS',
                assigned_reviewer = NULL
            WHERE train_id = $1 AND indent_number = $2
          `;
          updateParams = [trainId, indent_number];
        } else {
          updateQuery = `
            UPDATE dashboard_records 
            SET status = 'LOADING_IN_PROGRESS'
            WHERE train_id = $1 AND indent_number = $2
          `;
          updateParams = [trainId, indent_number];
        }
      } else {
        if (role === "SUPER_ADMIN") {
          updateQuery = `
            UPDATE dashboard_records 
            SET status = 'LOADING_IN_PROGRESS',
                assigned_reviewer = NULL
            WHERE train_id = $1
          `;
          updateParams = [trainId];
        } else {
          updateQuery = `
            UPDATE dashboard_records 
            SET status = 'LOADING_IN_PROGRESS'
            WHERE train_id = $1
          `;
          updateParams = [trainId];
        }
      }

      await pool.query(updateQuery, updateParams);

      // Add activity timeline entry for revocation
      const revokeUsername = username || req.headers["x-username"] || "System";
      const revokeRole = role === "SUPER_ADMIN" ? "SUPER_ADMIN" : "ADMIN";
      const activityType = role === "SUPER_ADMIN" ? "REVOKED_BY_SUPER_ADMIN" : "REVOKED";
      const notes = role === "SUPER_ADMIN"
        ? `Status revoked from ${status} to LOADING_IN_PROGRESS by SUPER_ADMIN`
        : `Status revoked from ${status} to LOADING_IN_PROGRESS`;

      await addActivityTimelineEntry(
        trainId,
        indent_number || null,
        activityType,
        revokeUsername,
        notes
      );

      res.json({
        message: "Train status revoked successfully.",
        newStatus: "LOADING_IN_PROGRESS"
      });
    } catch (err) {
      console.error("REVOKE TRAIN ERROR:", err);
      res.status(500).json({ message: "Failed to revoke train status" });
    }
  }
);



/* =====================================================
   HELPER: Add Activity Timeline Entry
===================================================== */
async function addActivityTimelineEntry(trainId, indentNumber, activityType, username, notes = null, rakeSerialNumber = null) {
  try {
    // ✅ FIX: Resolve rake_serial_number if not provided
    let actualRakeSerialNumber = rakeSerialNumber;
    if (!actualRakeSerialNumber) {
      // Try to get rake_serial_number from train_session or dashboard_records
      try {
        const trainSessionRes = await pool.query(
          "SELECT rake_serial_number FROM train_session WHERE train_id = $1 LIMIT 1",
          [trainId]
        );
        if (trainSessionRes.rows.length > 0 && trainSessionRes.rows[0].rake_serial_number) {
          actualRakeSerialNumber = trainSessionRes.rows[0].rake_serial_number;
        } else {
          // Fallback to dashboard_records
          const dashboardRes = await pool.query(
            "SELECT rake_serial_number FROM dashboard_records WHERE train_id = $1 LIMIT 1",
            [trainId]
          );
          if (dashboardRes.rows.length > 0 && dashboardRes.rows[0].rake_serial_number) {
            actualRakeSerialNumber = dashboardRes.rows[0].rake_serial_number;
          }
        }
      } catch (err) {
        console.error("[ACTIVITY] Error resolving rake_serial_number:", err);
        // Continue without rake_serial_number
      }
    }

    await pool.query(
      `
      INSERT INTO activity_timeline (train_id, rake_serial_number, indent_number, activity_type, username, activity_time, notes)
      VALUES ($1, $2, $3, $4, $5, NOW(), $6)
      `,
      [trainId, actualRakeSerialNumber || null, indentNumber || null, activityType, username, notes]
    );
    console.log(`[ACTIVITY] Added ${activityType} activity for train ${trainId}${actualRakeSerialNumber ? ` (rake: ${actualRakeSerialNumber})` : ''} by ${username}`);
  } catch (err) {
    console.error("[ACTIVITY] Error adding activity timeline entry:", err);
    // Don't throw - activity logging should not break main operations
  }
}

/* =====================================================
   APPLY DATABASE MIGRATIONS
===================================================== */
async function applyDatabaseMigrations() {
  try {
    // Apply activity timeline table creation
    const timelineTableSqlPath = path.join(__dirname, "create_activity_timeline_table.sql");
    const timelineTableSql = fs.readFileSync(timelineTableSqlPath, "utf8");
    await pool.query(timelineTableSql);
    console.log("[MIGRATION] Activity timeline table created successfully");
  } catch (err) {
    console.error("[MIGRATION] Error creating activity timeline table:", err);
    // Don't crash the server if migration fails - table might already exist
  }

  try {
    // Apply activity timeline columns to dispatch_records (for backward compatibility)
    const migrationSqlPath = path.join(__dirname, "add_activity_timeline.sql");
    const migrationSql = fs.readFileSync(migrationSqlPath, "utf8");
    await pool.query(migrationSql);
    console.log("[MIGRATION] Activity timeline columns added to dispatch_records successfully");
  } catch (err) {
    console.error("[MIGRATION] Error applying activity timeline migration:", err);
    // Don't crash the server if migration fails - columns might already exist
  }

  try {
    // Apply rake_serial_number to all tables
    const rakeSerialSqlPath = path.join(__dirname, "add_rake_serial_to_all_tables.sql");
    const rakeSerialSql = fs.readFileSync(rakeSerialSqlPath, "utf8");
    await pool.query(rakeSerialSql);
    console.log("[MIGRATION] rake_serial_number columns added to all tables successfully");
  } catch (err) {
    console.error("[MIGRATION] Error applying rake_serial_number migration:", err);
    // Don't crash the server if migration fails - columns might already exist
  }

  try {
    // Remove train_id from all tables except train_session
    const removeTrainIdSqlPath = path.join(__dirname, "remove_train_id_from_tables.sql");
    const removeTrainIdSql = fs.readFileSync(removeTrainIdSqlPath, "utf8");
    await pool.query(removeTrainIdSql);
    console.log("[MIGRATION] train_id removed from all tables (except train_session) successfully");
  } catch (err) {
    console.error("[MIGRATION] Error removing train_id columns:", err);
    // Don't crash the server if migration fails - columns might already be removed
  }
}

// Apply migrations on startup
applyDatabaseMigrations();

/* =====================================================
   APPLY DATABASE TRIGGER (Auto Sequential Train ID)
===================================================== */
async function applySequentialTrainIdTrigger() {
  try {
    // Check if trigger function exists
    const checkFunction = await pool.query(
      "SELECT EXISTS(SELECT 1 FROM pg_proc WHERE proname = 'assign_sequential_train_id_on_count')"
    );

    // Check if trigger exists
    const checkTrigger = await pool.query(
      "SELECT EXISTS(SELECT 1 FROM pg_trigger WHERE tgname = 'trigger_assign_sequential_train_id')"
    );

    if (checkFunction.rows[0].exists && checkTrigger.rows[0].exists) {
      // IMPORTANT: Always re-apply the SQL on startup so updates to the trigger logic take effect.
      // The SQL file uses CREATE OR REPLACE FUNCTION + DROP TRIGGER IF EXISTS, so it is safe to re-run.
      console.log("[TRIGGER] Sequential trigger already exists; re-applying SQL to ensure latest logic is active");
    }

    // Read and apply trigger SQL
    const triggerSqlPath = path.join(__dirname, "assign_sequential_train_id_trigger.sql");
    const triggerSql = fs.readFileSync(triggerSqlPath, "utf8");

    console.log("[TRIGGER] Applying sequential trigger SQL...");
    await pool.query(triggerSql);
    console.log("[TRIGGER] Sequential trigger applied successfully");
  } catch (err) {
    console.error("[TRIGGER] Error applying sequential trigger:", err);
    // Don't crash the server if trigger application fails
    // It can be applied manually later
  }
}

// Apply trigger on startup
applySequentialTrainIdTrigger();

// Endpoint to manually apply/verify trigger
app.post("/admin/apply-sequential-trigger", allowRoles(["ADMIN", "SUPER_ADMIN"]), async (req, res) => {
  try {
    const triggerSqlPath = path.join(__dirname, "assign_sequential_train_id_trigger.sql");
    const triggerSql = fs.readFileSync(triggerSqlPath, "utf8");

    await pool.query(triggerSql);

    // Verify trigger was created
    const checkTrigger = await pool.query(
      "SELECT EXISTS(SELECT 1 FROM pg_trigger WHERE tgname = 'trigger_assign_sequential_train_id')"
    );

    if (checkTrigger.rows[0].exists) {
      res.json({
        message: "Sequential train_id trigger applied successfully",
        triggerExists: true
      });
    } else {
      res.status(500).json({
        message: "Trigger SQL executed but trigger not found",
        triggerExists: false
      });
    }
  } catch (err) {
    console.error("[TRIGGER] Error applying trigger:", err);
    res.status(500).json({
      message: "Failed to apply trigger",
      error: err.message
    });
  }
});

// Endpoint to check if trigger exists
app.get("/admin/check-sequential-trigger", allowRoles(["ADMIN", "SUPER_ADMIN"]), async (req, res) => {
  try {
    const checkFunction = await pool.query(
      "SELECT EXISTS(SELECT 1 FROM pg_proc WHERE proname = 'assign_sequential_train_id_on_count')"
    );

    const checkTrigger = await pool.query(
      "SELECT EXISTS(SELECT 1 FROM pg_trigger WHERE tgname = 'trigger_assign_sequential_train_id')"
    );

    res.json({
      functionExists: checkFunction.rows[0].exists,
      triggerExists: checkTrigger.rows[0].exists,
      isActive: checkFunction.rows[0].exists && checkTrigger.rows[0].exists
    });
  } catch (err) {
    console.error("[TRIGGER] Error checking trigger:", err);
    res.status(500).json({
      message: "Failed to check trigger",
      error: err.message
    });
  }
});

// Repair endpoint: undo legacy sequential train_id (e.g., TRAIN-002-1) back to base train_id
// This is needed because older trigger versions mutated train_id; newer logic keeps train_id stable.
app.post(
  "/admin/repair-legacy-sequential-train-ids",
  allowRoles(["ADMIN", "SUPER_ADMIN"]),
  async (req, res) => {
    try {
      const { base_train_id } = req.body || {};
      if (!base_train_id || typeof base_train_id !== "string") {
        return res.status(400).json({ message: "base_train_id is required" });
      }

      // Find legacy child ids like BASE-N (but avoid financial-year style ids like 2025-26/02/001-1)
      const legacyIdsRes = await pool.query(
        `
        SELECT DISTINCT train_id
        FROM dashboard_records
        WHERE train_id LIKE $1
          AND train_id != $2
          AND train_id ~ ('^' || $2 || '-\\d+$')
        `,
        [`${base_train_id}-%`, base_train_id]
      );
      const legacyTrainIds = legacyIdsRes.rows.map(r => r.train_id);

      if (legacyTrainIds.length === 0) {
        return res.json({ message: "No legacy sequential train_ids found", updated: 0, legacyTrainIds: [] });
      }

      // Update dashboard_records back to base
      const dashUpdate = await pool.query(
        `
        UPDATE dashboard_records
        SET train_id = $1
        WHERE train_id = ANY($2)
        `,
        [base_train_id, legacyTrainIds]
      );

      // Update wagon_records back to base
      const wagonUpdate = await pool.query(
        `
        UPDATE wagon_records
        SET train_id = $1
        WHERE train_id = ANY($2)
        `,
        [base_train_id, legacyTrainIds]
      );

      // Update dispatch_records back to base
      const dispatchUpdate = await pool.query(
        `
        UPDATE dispatch_records
        SET train_id = $1
        WHERE train_id = ANY($2)
        `,
        [base_train_id, legacyTrainIds]
      );

      res.json({
        message: "Legacy sequential train_ids repaired",
        legacyTrainIds,
        updated: legacyTrainIds.length,
        dashboard_rows: dashUpdate.rowCount,
        wagon_rows: wagonUpdate.rowCount,
        dispatch_rows: dispatchUpdate.rowCount,
      });
    } catch (err) {
      console.error("[TRIGGER] Error repairing legacy sequential train_ids:", err);
      res.status(500).json({ message: "Failed to repair legacy sequential train_ids", error: err.message });
    }
  }
);

/* =====================================================
   CHECK FOR RECENT SEQUENTIAL TRAIN ID ASSIGNMENTS
   (Polling endpoint for Dashboard)
===================================================== */
app.get("/train/check-sequential-assignments", allowRoles(["ADMIN", "REVIEWER", "SUPER_ADMIN"]), async (req, res) => {
  try {
    const { since_seconds = 30 } = req.query; // Default: check last 30 seconds

    // Query train_session for trains with sequential pattern (e.g., 2024-25/01/001-1) 
    // that were created recently (trigger creates new train_session records)
    // We check trains that match the pattern: financial_year/month/sequence-sequential (e.g., 2024-25/01/001-1)
    // Then join with dashboard_records to get indent_number
    const result = await pool.query(
      `
      SELECT 
        ts.train_id,
        COALESCE(d.indent_number, '') as indent_number,
        ts.created_time,
        COALESCE(d.status, '') as status
      FROM train_session ts
      LEFT JOIN dashboard_records d ON d.train_id = ts.train_id
      WHERE ts.train_id ~ '^(.+\/\d+\/\d+)-(\d+)$'
        AND ts.created_time >= NOW() - INTERVAL '${parseInt(since_seconds)} seconds'
      ORDER BY ts.created_time DESC
      LIMIT 100
      `
    );

    // Group by base train_id and indent_number to return unique assignments
    const assignments = result.rows.map(row => {
      // Extract base train_id (remove sequential suffix)
      const baseTrainId = row.train_id.replace(/-(\d+)$/, '');
      return {
        train_id: row.train_id,
        indent_number: row.indent_number || '',
        base_train_id: baseTrainId,
        created_time: row.created_time,
        status: row.status || ''
      };
    });

    // Remove duplicates (same train_id might appear multiple times if multiple dashboard_records exist)
    const uniqueAssignments = assignments.reduce((acc, curr) => {
      const key = `${curr.train_id}_${curr.indent_number}`;
      if (!acc[key]) {
        acc[key] = curr;
      }
      return acc;
    }, {});

    const finalAssignments = Object.values(uniqueAssignments);

    console.log(`[SEQUENTIAL CHECK] Found ${finalAssignments.length} recent sequential assignments (last ${since_seconds}s)`);

    res.json({
      assignments: finalAssignments,
      count: finalAssignments.length,
      since_seconds: parseInt(since_seconds)
    });
  } catch (err) {
    console.error("[SEQUENTIAL CHECK] Error checking sequential assignments:", err);
    res.status(500).json({
      message: "Failed to check sequential assignments",
      error: err.message
    });
  }
});

/* =====================================================
   START SERVER
===================================================== */
app.listen(5000, "0.0.0.0", () => {
  console.log("Backend running on all network interfaces");
});
